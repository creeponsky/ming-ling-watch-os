Directory tree of ming-ling-watch-os:

├── ming-ling-watch-os Watch App
│   ├── Assets.xcassets
│   │   ├── AccentColor.colorset
│   │   │   └── Contents.json
│   │   ├── AppIcon.appiconset
│   │   │   ├── Contents.json
│   │   │   └── mingling-icon.png
│   │   ├── Color.colorset
│   │   │   └── Contents.json
│   │   ├── huohuo.imageset
│   │   │   ├── Contents.json
│   │   │   ├── x1.png
│   │   │   ├── x2.png
│   │   │   └── x3.png
│   │   ├── huohuo_speak.imageset
│   │   │   ├── Contents.json
│   │   │   ├── Group 1.png
│   │   │   ├── Group 2.png
│   │   │   └── Group 3.png
│   │   ├── jinjin.imageset
│   │   │   ├── Contents.json
│   │   │   ├── x1.png
│   │   │   ├── x2.png
│   │   │   └── x3.png
│   │   ├── jinjin_speak.imageset
│   │   │   ├── Contents.json
│   │   │   └── Group 1.png
│   │   ├── mumu.imageset
│   │   │   ├── Contents.json
│   │   │   ├── x1.png
│   │   │   ├── x2.png
│   │   │   └── x3.png
│   │   ├── mumu_speak.imageset
│   │   │   ├── Contents.json
│   │   │   ├── mumu_speak 1.png
│   │   │   ├── mumu_speak 2.png
│   │   │   └── mumu_speak.png
│   │   ├── shuishui.imageset
│   │   │   ├── Contents.json
│   │   │   ├── x1.png
│   │   │   ├── x2.png
│   │   │   └── x3.png
│   │   ├── shuishui_speak.imageset
│   │   │   ├── Contents.json
│   │   │   └── Group 1.png
│   │   ├── tutu.imageset
│   │   │   ├── Contents.json
│   │   │   ├── x1.png
│   │   │   ├── x2.png
│   │   │   └── x3.png
│   │   ├── tutu_speak.imageset
│   │   │   ├── Contents.json
│   │   │   └── Group 1.png
│   │   └── Contents.json
│   ├── Extensions
│   │   └── Color+Extensions.swift
│   ├── GIFs
│   │   └── mumu
│   │       └── happy
│   │           ├── 1.gif
│   │           ├── 2.gif
│   │           └── 3.gif
│   ├── Managers
│   │   ├── DeviceManager.swift
│   │   ├── HealthKitManager.swift
│   │   ├── LocationManager.swift
│   │   └── MotionManager.swift
│   ├── Models
│   │   ├── BaziData.swift
│   │   ├── HealthReminders.swift
│   │   └── UserProfile.swift
│   ├── Services
│   │   ├── BaziAPIService.swift
│   │   ├── EnvironmentSensorManager.swift
│   │   ├── HealthMonitoringService.swift
│   │   ├── NotificationController.swift
│   │   ├── SystemNotificationManager.swift
│   │   ├── UserProfileManager.swift
│   │   └── WatchOSAppDelegate.swift
│   ├── Utils
│   │   ├── GIFAnimationManager.swift
│   │   ├── NotificationUtils.swift
│   │   ├── PetUtils.swift
│   │   └── ReminderContentManager.swift
│   ├── Views
│   │   ├── BaziDetailView.swift
│   │   ├── BirthdaySelectionView.swift
│   │   ├── GIFAnimationView.swift
│   │   ├── HealthCardView.swift
│   │   ├── HealthDashboardPageView.swift
│   │   ├── HealthDetailView.swift
│   │   ├── IntimacyChangeView.swift
│   │   ├── MainPetView.swift
│   │   ├── PetAnimationView.swift
│   │   ├── PetPageView.swift
│   │   └── SettingsView.swift
│   ├── ming-ling Watch App.entitlements
│   ├── ming-ling-watch-os Watch App.entitlements
│   └── ming_ling_watch_osApp.swift
├── ming-ling-watch-os Watch AppTests
│   └── ming_ling_watch_os_Watch_AppTests.swift
├── ming-ling-watch-os Watch AppUITests
│   ├── ming_ling_watch_os_Watch_AppUITests.swift
│   └── ming_ling_watch_os_Watch_AppUITestsLaunchTests.swift
├── ming-ling-watch-os.xcodeproj
│   ├── project.xcworkspace
│   │   └── contents.xcworkspacedata
│   ├── xcuserdata
│   │   └── zuowenhao.xcuserdatad
│   │       └── xcschemes
│   │           └── xcschememanagement.plist
│   └── project.pbxproj
├── ming-ling-watch-os.xcworkspace
│   └── contents.xcworkspacedata
├── mingling-notifcation
│   ├── Info.plist
│   └── NotificationService.swift
├── IMPLEMENTATION_SUMMARY.md
├── README.md
├── animation1.gif
└── ming-ling-watch-os-Watch-App-Info.plist

================================================================================

File contents:

----
FilePath: IMPLEMENTATION_SUMMARY.md
Lines: 144
# 功能实现总结

## 已完成的功能

### 1. 亲密值系统 ✅

#### 核心功能
- **三级亲密值等级**：
  - 等级1（0-49分）：陌生
  - 等级2（50-79分）：友好  
  - 等级3（80-100分）：亲密

#### 实现文件
- `UserProfile.swift` - 添加亲密值模型和计算方法
- `UserProfileManager.swift` - 添加亲密值管理方法
- `SettingsView.swift` - 添加亲密值显示和测试按钮
- `IntimacyChangeView.swift` - 亲密值变化通知组件

#### 功能特性
- 亲密值进度条显示
- 等级图标和颜色区分
- 距离下一等级积分显示
- 增加/减少亲密值的测试按钮
- 亲密值变化时的动画通知

### 2. 久坐Follow-up检测 ✅

#### 检测逻辑
1. **触发条件**：1小时内步数<40步
2. **提醒发送**：发送久坐建议通知
3. **后续监测**：10分钟内检测步数变化
4. **成功条件**：提醒后步数增加100+步
5. **奖励机制**：成功活动后增加10点亲密值

#### 实现文件
- `HealthMonitoringService.swift` - 久坐检测和后续监测逻辑
- `HealthKitManager.swift` - 添加获取指定时间段步数方法
- `MotionManager.swift` - 添加步数监测回调功能

#### 检测流程
```
久坐检测 → 发送提醒 → 开始后续监测 → 检测活动 → 发送成功通知 → 增加亲密值
```

### 3. 压力Follow-up检测 ✅

#### 检测逻辑
1. **触发条件**：HRV持续低于个人基线20%
2. **提醒发送**：发送压力建议通知
3. **后续监测**：30分钟后检查HRV改善情况
4. **成功条件**：HRV恢复到基线80%以上
5. **奖励机制**：成功改善后增加15点亲密值

#### 实现文件
- `HealthMonitoringService.swift` - 压力检测和后续监测逻辑
- `HealthKitManager.swift` - 添加HRV监测和获取当前HRV方法

### 4. 通知系统优化 ✅

#### 清理无用通知
- 删除了`NotificationUtils.swift`中的无用健康通知
- 删除了`PetUtils.swift`中的无用健康相关通知
- 保留了基于`ReminderContentManager`的结构化通知

#### 通知内容
所有通知内容都基于你提供的`passive_health_reminders`配置：
- 晒太阳提醒
- 压力大提醒  
- 久坐提醒
- 运动检测提醒
- 睡眠监测提醒

### 5. 亲密值变化通知 ✅

#### 实现特性
- 在宠物页面显示亲密值变化通知
- 支持增加和减少的动画效果
- 3秒后自动消失
- 心形图标和颜色区分

#### 显示位置
- 宠物图片下方
- 对话框卡片下方
- 动画过渡效果

#### 测试入口
- 在设置页面添加"功能测试"入口
- 可以测试所有新功能

## 技术实现细节

### 数据持久化
- 亲密值数据通过`UserDefaults`保存
- 支持应用重启后数据恢复

### 健康数据监测
- 使用`HealthKit`获取步数和HRV数据
- 使用`CoreMotion`进行实时步数监测
- 支持后台监测和前台回调

### 通知系统
- 使用`UserNotifications`框架
- 支持自定义通知内容
- 支持后续提醒和延时通知

### UI组件
- 使用`SwiftUI`构建所有界面
- 支持动画和过渡效果
- 响应式设计适配Apple Watch

## 使用流程

### 1. 亲密值系统
1. 在设置页面查看当前亲密值
2. 使用测试按钮增加或减少亲密值
3. 观察等级变化和进度条更新
4. 在宠物页面查看亲密值变化通知

### 2. 久坐检测
1. 系统自动监测步数
2. 检测到久坐时发送提醒
3. 开始后续监测（10分钟）
4. 检测到活动时发送成功通知并增加亲密值

### 3. 压力检测
1. 系统自动监测HRV
2. 检测到压力时发送提醒
3. 开始后续监测（30分钟）
4. 检测到改善时发送成功通知并增加亲密值

## 注意事项

1. **权限要求**：需要HealthKit权限来获取健康数据
2. **设备要求**：需要Apple Watch来获取步数和HRV数据
3. **测试环境**：在模拟器中某些功能可能无法正常工作
4. **数据准确性**：实际使用中需要根据用户数据调整阈值

## 未来扩展

1. **更多健康指标**：可以添加更多健康指标的监测
2. **个性化阈值**：根据用户历史数据调整触发阈值
3. **更多奖励机制**：可以添加更多获得亲密值的方式
4. **数据统计**：添加亲密值变化的历史统计
5. **成就系统**：基于亲密值等级添加成就系统 
----

----
FilePath: README.md
Lines: 111
# 健康助手 Watch App

一个基于五行理论的 Apple Watch 健康监测应用，根据用户的生日计算五行属性，提供个性化的健康建议和提醒。

## 功能特性

### 核心功能
- **五行属性计算**: 通过生日计算用户的五行属性（金、木、水、火、土）
- **个性化健康建议**: 根据五行属性提供针对性的健康建议
- **实时健康监测**: 监测心率、HRV、步数、睡眠等健康数据
- **智能提醒系统**: 基于触发条件发送个性化健康提醒
- **环境感知**: 监测环境光和位置信息，提供晒太阳建议

### 健康监测项目
1. **晒太阳提醒**: 基于UV指数、时间和环境光
2. **压力监测**: 基于HRV数据
3. **久坐提醒**: 基于步数监测
4. **运动检测**: 基于心率变化
5. **睡眠监测**: 基于睡眠时长

## 项目结构

```
ming-ling-watch-os Watch App/
├── Models/
│   ├── UserProfile.swift          # 用户档案模型
│   └── HealthReminders.swift      # 健康提醒模型
├── Services/
│   ├── BaziAPIService.swift       # 八字API服务
│   ├── UserProfileManager.swift   # 用户档案管理
│   ├── HealthMonitoringService.swift # 健康监测服务
│   ├── SystemNotificationManager.swift # 系统通知管理
│   └── EnvironmentSensorManager.swift # 环境传感器管理
├── Views/
│   ├── BirthdaySelectionView.swift # 生日选择界面
│   ├── NewMainDashboardView.swift # 主界面
│   └── SettingsView.swift         # 设置界面
└── Managers/
    ├── HealthKitManager.swift     # HealthKit管理
    ├── LocationManager.swift      # 位置管理
    └── MotionManager.swift        # 运动管理
```

## 技术架构

### 数据层
- **UserProfile**: 用户档案数据模型
- **HealthReminders**: 健康提醒配置模型
- **FiveElements**: 五行属性模型

### 服务层
- **BaziAPIService**: 八字API服务，获取五行属性
- **UserProfileManager**: 用户档案管理，包括亲密值系统
- **HealthMonitoringService**: 健康监测服务，处理各种健康数据
- **SystemNotificationManager**: 系统通知管理，支持建议和完成通知
- **EnvironmentSensorManager**: 环境传感器管理，监测光线和位置

### 管理层
- **HealthKitManager**: HealthKit数据管理
- **LocationManager**: 位置服务管理
- **MotionManager**: 运动数据管理

### 视图层
- **BirthdaySelectionView**: 生日选择界面
- **NewMainDashboardView**: 主仪表板界面
- **SettingsView**: 设置界面

## 通知系统

### 通知类型
1. **建议通知**: 当检测到健康问题时发送个性化建议
2. **完成通知**: 当用户完成建议后发送鼓励和亲密度奖励

### 通知特性
- 支持GIF动画显示
- 自动处理亲密度奖励
- 支持延时发送
- 支持随机建议/完成通知
- 自定义Long Look界面

## 亲密值系统

### 等级划分
- **等级1（0-49分）**: 陌生
- **等级2（50-79分）**: 友好
- **等级3（80-100分）**: 亲密

### 获取方式
- 完成健康建议：+20点
- 改善压力状态：+20点
- 开始活动：+20点

## 开发环境

- **平台**: watchOS 10.0+
- **语言**: Swift 5.9
- **框架**: SwiftUI, HealthKit, UserNotifications
- **设备**: Apple Watch Series 4+

## 安装和运行

1. 克隆项目到本地
2. 使用Xcode打开项目
3. 选择Apple Watch模拟器或真机
4. 运行项目

## 注意事项

- 需要HealthKit权限来访问健康数据
- 需要通知权限来发送提醒
- 需要位置权限来提供环境相关建议 
----

----
FilePath: animation1.gif
Lines: 1
无法读取文件内容: 'utf-8' codec can't decode byte 0xf7 in position 10: invalid start byte
----

----
FilePath: ming-ling-watch-os Watch App/Assets.xcassets/AccentColor.colorset/Contents.json
Lines: 11
{
  "colors" : [
    {
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

----

----
FilePath: ming-ling-watch-os Watch App/Assets.xcassets/AppIcon.appiconset/Contents.json
Lines: 14
{
  "images" : [
    {
      "filename" : "mingling-icon.png",
      "idiom" : "universal",
      "platform" : "watchos",
      "size" : "1024x1024"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

----

----
FilePath: ming-ling-watch-os Watch App/Assets.xcassets/AppIcon.appiconset/mingling-icon.png
Lines: 1
无法读取文件内容: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
----

----
FilePath: ming-ling-watch-os Watch App/Assets.xcassets/Color.colorset/Contents.json
Lines: 38
{
  "colors" : [
    {
      "color" : {
        "color-space" : "srgb",
        "components" : {
          "alpha" : "1.000",
          "blue" : "1.000",
          "green" : "1.000",
          "red" : "1.000"
        }
      },
      "idiom" : "universal"
    },
    {
      "appearances" : [
        {
          "appearance" : "luminosity",
          "value" : "dark"
        }
      ],
      "color" : {
        "color-space" : "srgb",
        "components" : {
          "alpha" : "1.000",
          "blue" : "1.000",
          "green" : "1.000",
          "red" : "1.000"
        }
      },
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

----

----
FilePath: ming-ling-watch-os Watch App/Assets.xcassets/Contents.json
Lines: 6
{
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

----

----
FilePath: ming-ling-watch-os Watch App/Assets.xcassets/huohuo.imageset/Contents.json
Lines: 23
{
  "images" : [
    {
      "filename" : "x1.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "x2.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "x3.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

----

----
FilePath: ming-ling-watch-os Watch App/Assets.xcassets/huohuo.imageset/x1.png
Lines: 1
无法读取文件内容: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
----

----
FilePath: ming-ling-watch-os Watch App/Assets.xcassets/huohuo.imageset/x2.png
Lines: 1
无法读取文件内容: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
----

----
FilePath: ming-ling-watch-os Watch App/Assets.xcassets/huohuo.imageset/x3.png
Lines: 1
无法读取文件内容: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
----

----
FilePath: ming-ling-watch-os Watch App/Assets.xcassets/huohuo_speak.imageset/Contents.json
Lines: 23
{
  "images" : [
    {
      "filename" : "Group 1.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "Group 2.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "Group 3.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

----

----
FilePath: ming-ling-watch-os Watch App/Assets.xcassets/huohuo_speak.imageset/Group 1.png
Lines: 1
无法读取文件内容: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
----

----
FilePath: ming-ling-watch-os Watch App/Assets.xcassets/huohuo_speak.imageset/Group 2.png
Lines: 1
无法读取文件内容: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
----

----
FilePath: ming-ling-watch-os Watch App/Assets.xcassets/huohuo_speak.imageset/Group 3.png
Lines: 1
无法读取文件内容: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
----

----
FilePath: ming-ling-watch-os Watch App/Assets.xcassets/jinjin.imageset/Contents.json
Lines: 23
{
  "images" : [
    {
      "filename" : "x1.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "x2.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "x3.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
} 
----

----
FilePath: ming-ling-watch-os Watch App/Assets.xcassets/jinjin.imageset/x1.png
Lines: 1
无法读取文件内容: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
----

----
FilePath: ming-ling-watch-os Watch App/Assets.xcassets/jinjin.imageset/x2.png
Lines: 1
无法读取文件内容: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
----

----
FilePath: ming-ling-watch-os Watch App/Assets.xcassets/jinjin.imageset/x3.png
Lines: 1
无法读取文件内容: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
----

----
FilePath: ming-ling-watch-os Watch App/Assets.xcassets/jinjin_speak.imageset/Contents.json
Lines: 22
{
  "images" : [
    {
      "filename" : "Group 1.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "Group 3.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

----

----
FilePath: ming-ling-watch-os Watch App/Assets.xcassets/jinjin_speak.imageset/Group 1.png
Lines: 1
无法读取文件内容: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
----

----
FilePath: ming-ling-watch-os Watch App/Assets.xcassets/mumu.imageset/Contents.json
Lines: 23
{
  "images" : [
    {
      "filename" : "x1.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "x2.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "x3.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

----

----
FilePath: ming-ling-watch-os Watch App/Assets.xcassets/mumu.imageset/x1.png
Lines: 1
无法读取文件内容: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
----

----
FilePath: ming-ling-watch-os Watch App/Assets.xcassets/mumu.imageset/x2.png
Lines: 1
无法读取文件内容: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
----

----
FilePath: ming-ling-watch-os Watch App/Assets.xcassets/mumu.imageset/x3.png
Lines: 1
无法读取文件内容: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
----

----
FilePath: ming-ling-watch-os Watch App/Assets.xcassets/mumu_speak.imageset/Contents.json
Lines: 23
{
  "images" : [
    {
      "filename" : "mumu_speak.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "mumu_speak 1.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "mumu_speak 2.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

----

----
FilePath: ming-ling-watch-os Watch App/Assets.xcassets/mumu_speak.imageset/mumu_speak 1.png
Lines: 1
无法读取文件内容: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
----

----
FilePath: ming-ling-watch-os Watch App/Assets.xcassets/mumu_speak.imageset/mumu_speak 2.png
Lines: 1
无法读取文件内容: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
----

----
FilePath: ming-ling-watch-os Watch App/Assets.xcassets/mumu_speak.imageset/mumu_speak.png
Lines: 1
无法读取文件内容: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
----

----
FilePath: ming-ling-watch-os Watch App/Assets.xcassets/shuishui.imageset/Contents.json
Lines: 23
{
  "images" : [
    {
      "filename" : "x1.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "x2.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "x3.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

----

----
FilePath: ming-ling-watch-os Watch App/Assets.xcassets/shuishui.imageset/x1.png
Lines: 1
无法读取文件内容: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
----

----
FilePath: ming-ling-watch-os Watch App/Assets.xcassets/shuishui.imageset/x2.png
Lines: 1
无法读取文件内容: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
----

----
FilePath: ming-ling-watch-os Watch App/Assets.xcassets/shuishui.imageset/x3.png
Lines: 1
无法读取文件内容: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
----

----
FilePath: ming-ling-watch-os Watch App/Assets.xcassets/shuishui_speak.imageset/Contents.json
Lines: 22
{
  "images" : [
    {
      "filename" : "Group 1.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "Group 3.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

----

----
FilePath: ming-ling-watch-os Watch App/Assets.xcassets/shuishui_speak.imageset/Group 1.png
Lines: 1
无法读取文件内容: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
----

----
FilePath: ming-ling-watch-os Watch App/Assets.xcassets/tutu.imageset/Contents.json
Lines: 23
{
  "images" : [
    {
      "filename" : "x1.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "x2.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "x3.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

----

----
FilePath: ming-ling-watch-os Watch App/Assets.xcassets/tutu.imageset/x1.png
Lines: 1
无法读取文件内容: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
----

----
FilePath: ming-ling-watch-os Watch App/Assets.xcassets/tutu.imageset/x2.png
Lines: 1
无法读取文件内容: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
----

----
FilePath: ming-ling-watch-os Watch App/Assets.xcassets/tutu.imageset/x3.png
Lines: 1
无法读取文件内容: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
----

----
FilePath: ming-ling-watch-os Watch App/Assets.xcassets/tutu_speak.imageset/Contents.json
Lines: 22
{
  "images" : [
    {
      "filename" : "Group 1.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "Group 3.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

----

----
FilePath: ming-ling-watch-os Watch App/Assets.xcassets/tutu_speak.imageset/Group 1.png
Lines: 1
无法读取文件内容: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
----

----
FilePath: ming-ling-watch-os Watch App/Extensions/Color+Extensions.swift
Lines: 42
import SwiftUI

extension Color {
    // 五行元素颜色
    static let elementGold = Color(red: 1.0, green: 0.8, blue: 0.0)
    static let elementWood = Color(red: 0.2, green: 0.8, blue: 0.2)
    static let elementWater = Color(red: 0.0, green: 0.6, blue: 1.0)
    static let elementFire = Color(red: 1.0, green: 0.3, blue: 0.0)
    static let elementEarth = Color(red: 1.0, green: 0.6, blue: 0.0)
    
    // 健康状态颜色
    static let healthGood = Color.green
    static let healthWarning = Color.orange
    static let healthDanger = Color.red
    static let healthNeutral = Color.gray
    
    // 自定义颜色初始化
    init(hex: String) {
        let hex = hex.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)
        var int: UInt64 = 0
        Scanner(string: hex).scanHexInt64(&int)
        let a, r, g, b: UInt64
        switch hex.count {
        case 3: // RGB (12-bit)
            (a, r, g, b) = (255, (int >> 8) * 17, (int >> 4 & 0xF) * 17, (int & 0xF) * 17)
        case 6: // RGB (24-bit)
            (a, r, g, b) = (255, int >> 16, int >> 8 & 0xFF, int & 0xFF)
        case 8: // ARGB (32-bit)
            (a, r, g, b) = (int >> 24, int >> 16 & 0xFF, int >> 8 & 0xFF, int & 0xFF)
        default:
            (a, r, g, b) = (1, 1, 1, 0)
        }
        
        self.init(
            .sRGB,
            red: Double(r) / 255,
            green: Double(g) / 255,
            blue:  Double(b) / 255,
            opacity: Double(a) / 255
        )
    }
} 
----

----
FilePath: ming-ling-watch-os Watch App/GIFs/mumu/happy/1.gif
Lines: 1
无法读取文件内容: 'utf-8' codec can't decode byte 0xf7 in position 10: invalid start byte
----

----
FilePath: ming-ling-watch-os Watch App/GIFs/mumu/happy/2.gif
Lines: 1
无法读取文件内容: 'utf-8' codec can't decode byte 0xf7 in position 10: invalid start byte
----

----
FilePath: ming-ling-watch-os Watch App/GIFs/mumu/happy/3.gif
Lines: 1
无法读取文件内容: 'utf-8' codec can't decode byte 0xf7 in position 10: invalid start byte
----

----
FilePath: ming-ling-watch-os Watch App/Managers/DeviceManager.swift
Lines: 209
//
//  DeviceManager.swift
//  test-app Watch App
//
//  Created by CreepOnSky on 2025/7/24.
//

import Foundation
import WatchKit
import UIKit

class DeviceManager: NSObject, ObservableObject {
    private let device = WKInterfaceDevice.current()
    private var updateTimer: Timer?
    
    @Published var deviceName: String = ""
    @Published var systemName: String = ""
    @Published var systemVersion: String = ""
    @Published var model: String = ""
    @Published var batteryLevel: Double = 0
    @Published var batteryState: String = "Unknown"
    @Published var screenBrightness: Double = 0
    @Published var crownOrientation: String = "Unknown"
    @Published var digitalCrownStatus: String = "Unknown"
    @Published var waterLockStatus: String = "Unknown"
    @Published var complicationFamily: String = "Unknown"
    @Published var wristLocation: String = "Unknown"
    @Published var crownDirection: String = "Unknown"
    @Published var timeZone: String = ""
    @Published var locale: String = ""
    @Published var availableStorage: Double = 0
    @Published var totalStorage: Double = 0
    @Published var memoryUsage: Double = 0
    @Published var cpuUsage: Double = 0
    
    override init() {
        super.init()
        updateDeviceInfo()
    }
    
    func startUpdates() {
        updateTimer = Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { [weak self] _ in
            self?.updateDeviceInfo()
        }
    }
    
    func stopUpdates() {
        updateTimer?.invalidate()
        updateTimer = nil
    }
    
    private func updateDeviceInfo() {
        // 设备基本信息
        deviceName = device.name
        systemName = device.systemName
        systemVersion = device.systemVersion
        model = device.model
        
        // 电池信息
        batteryLevel = Double(device.batteryLevel)
        switch device.batteryState {
        case .charging:
            batteryState = "Charging"
        case .full:
            batteryState = "Full"
        case .unplugged:
            batteryState = "Unplugged"
        case .unknown:
            batteryState = "Unknown"
        @unknown default:
            batteryState = "Unknown"
        }
        
        // 屏幕亮度
        screenBrightness = 0.5 // WKInterfaceDevice没有screenBrightness属性，使用默认值
        
        // 表冠信息
        crownOrientation = getCrownOrientation()
        digitalCrownStatus = getDigitalCrownStatus()
        
        // 防水锁状态
        waterLockStatus = getWaterLockStatus()
        
        // 表盘信息
        complicationFamily = getComplicationFamily()
        
        // 手腕位置
        wristLocation = getWristLocation()
        
        // 表冠方向
        crownDirection = getCrownDirection()
        
        // 时区和地区
        timeZone = TimeZone.current.identifier
        locale = Locale.current.identifier
        
        // 存储信息
        updateStorageInfo()
        
        // 内存和CPU使用情况
        updateSystemResources()
    }
    
    private func getCrownOrientation() -> String {
        // 注意：这些API可能在实际Apple Watch上不可用
        // 这里提供示例实现
        return "Right"
    }
    
    private func getDigitalCrownStatus() -> String {
        // 注意：这些API可能在实际Apple Watch上不可用
        // 这里提供示例实现
        return "Available"
    }
    
    private func getWaterLockStatus() -> String {
        // 注意：这些API可能在实际Apple Watch上不可用
        // 这里提供示例实现
        return "Unlocked"
    }
    
    private func getComplicationFamily() -> String {
        // 注意：这些API可能在实际Apple Watch上不可用
        // 这里提供示例实现
        return "Modular Small"
    }
    
    private func getWristLocation() -> String {
        // 注意：这些API可能在实际Apple Watch上不可用
        // 这里提供示例实现
        return "Left"
    }
    
    private func getCrownDirection() -> String {
        // 注意：这些API可能在实际Apple Watch上不可用
        // 这里提供示例实现
        return "Clockwise"
    }
    
    private func updateStorageInfo() {
        // 注意：这些API可能在实际Apple Watch上不可用
        // 这里提供示例实现
        let fileManager = FileManager.default
        do {
            let attributes = try fileManager.attributesOfFileSystem(forPath: NSHomeDirectory())
            if let totalSize = attributes[.systemSize] as? NSNumber {
                totalStorage = Double(truncating: totalSize) / (1024 * 1024 * 1024) // Convert to GB
            }
            if let freeSize = attributes[.systemFreeSize] as? NSNumber {
                availableStorage = Double(truncating: freeSize) / (1024 * 1024 * 1024) // Convert to GB
            }
        } catch {
            totalStorage = 32.0 // 默认值
            availableStorage = 16.0 // 默认值
        }
    }
    
    private func updateSystemResources() {
        // 注意：这些API可能在实际Apple Watch上不可用
        // 这里提供示例实现
        memoryUsage = getMemoryUsage()
        cpuUsage = getCPUUsage()
    }
    
    private func getMemoryUsage() -> Double {
        // 注意：这些API可能在实际Apple Watch上不可用
        // 这里提供示例实现
        var info = mach_task_basic_info()
        var count = mach_msg_type_number_t(MemoryLayout<mach_task_basic_info>.size)/4
        
        let kerr: kern_return_t = withUnsafeMutablePointer(to: &info) {
            $0.withMemoryRebound(to: integer_t.self, capacity: 1) {
                task_info(mach_task_self_,
                         task_flavor_t(MACH_TASK_BASIC_INFO),
                         $0,
                         &count)
            }
        }
        
        if kerr == KERN_SUCCESS {
            return Double(info.resident_size) / (1024 * 1024) // Convert to MB
        }
        
        return 0.0
    }
    
    private func getCPUUsage() -> Double {
        // 注意：这些API可能在实际Apple Watch上不可用
        // 这里提供示例实现
        var info = mach_task_basic_info()
        var count = mach_msg_type_number_t(MemoryLayout<mach_task_basic_info>.size)/4
        
        let kerr: kern_return_t = withUnsafeMutablePointer(to: &info) {
            $0.withMemoryRebound(to: integer_t.self, capacity: 1) {
                task_info(mach_task_self_,
                         task_flavor_t(MACH_TASK_BASIC_INFO),
                         $0,
                         &count)
            }
        }
        
        if kerr == KERN_SUCCESS {
            // 这里只是示例，实际CPU使用率需要更复杂的计算
            return Double.random(in: 10...50) // 随机值作为示例
        }
        
        return 0.0
    }
} 
----

----
FilePath: ming-ling-watch-os Watch App/Managers/HealthKitManager.swift
Lines: 484
//
//  HealthKitManager.swift
//  test-app Watch App
//
//  Created by CreepOnSky on 2025/7/24.
//

import Foundation
import HealthKit

class HealthKitManager: ObservableObject {
    static let shared = HealthKitManager()
    private let healthStore = HKHealthStore()
    
    @Published var isAuthorized = false
    @Published var heartRate: Int = 0
    @Published var activeEnergy: Double = 0
    @Published var steps: Int = 0
    @Published var distance: Double = 0
    @Published var flightsClimbed: Int = 0
    @Published var exerciseTime: Int = 0
    @Published var standHours: Int = 0
    @Published var vo2Max: Double = 0
    @Published var restingHeartRate: Int = 0
    @Published var walkingHeartRate: Int = 0
    @Published var heartRateVariability: Double = 0
    @Published var bloodOxygen: Double = 0
    @Published var bodyTemperature: Double = 0
    @Published var respiratoryRate: Double = 0
    @Published var sleepAnalysis: String = "暂无数据"
    
    private var heartRateQuery: HKQuery?
    private var activeEnergyQuery: HKQuery?
    private var hrvQuery: HKQuery?
    @Published var isUpdating = false
    
    init() {
        checkAuthorizationStatus()
        // 如果已经授权，立即开始获取数据
        if isAuthorized {
            startHeartRateUpdates()
            fetchTodayData()
        }
    }
    
    func requestAuthorization() {
        guard HKHealthStore.isHealthDataAvailable() else {
            print("HealthKit is not available on this device")
            return
        }
        
        let typesToRead: Set<HKObjectType> = [
            HKObjectType.quantityType(forIdentifier: .heartRate)!,
            HKObjectType.quantityType(forIdentifier: .activeEnergyBurned)!,
            HKObjectType.quantityType(forIdentifier: .stepCount)!,
            HKObjectType.quantityType(forIdentifier: .distanceWalkingRunning)!,
            HKObjectType.quantityType(forIdentifier: .flightsClimbed)!,
            HKObjectType.quantityType(forIdentifier: .appleExerciseTime)!,
            HKObjectType.quantityType(forIdentifier: .appleStandTime)!,
            HKObjectType.quantityType(forIdentifier: .vo2Max)!,
            HKObjectType.quantityType(forIdentifier: .restingHeartRate)!,
            HKObjectType.quantityType(forIdentifier: .walkingHeartRateAverage)!,
            HKObjectType.quantityType(forIdentifier: .heartRateVariabilitySDNN)!,
            HKObjectType.quantityType(forIdentifier: .oxygenSaturation)!,
            HKObjectType.quantityType(forIdentifier: .bodyTemperature)!,
            HKObjectType.quantityType(forIdentifier: .respiratoryRate)!,
            HKObjectType.categoryType(forIdentifier: .sleepAnalysis)!
        ]
        
        healthStore.requestAuthorization(toShare: nil, read: typesToRead) { [weak self] success, error in
            DispatchQueue.main.async {
                self?.isAuthorized = success
                if success {
                    print("HealthKit授权成功")
                    self?.startHeartRateUpdates()
                    self?.fetchTodayData()
                } else {
                    print("HealthKit授权失败: \(error?.localizedDescription ?? "未知错误")")
                }
            }
        }
    }
    
    private func checkAuthorizationStatus() {
        guard HKHealthStore.isHealthDataAvailable() else { 
            print("HealthKit在此设备上不可用")
            return 
        }
        
        let heartRateType = HKObjectType.quantityType(forIdentifier: .heartRate)!
        let status = healthStore.authorizationStatus(for: heartRateType)
        isAuthorized = status == .sharingAuthorized
        print("HealthKit授权状态: \(status.rawValue), 已授权: \(isAuthorized)")
    }
    
    // MARK: - 心率监测
    func startHeartRateMonitoring(completion: @escaping (Double) -> Void) {
        guard let heartRateType = HKObjectType.quantityType(forIdentifier: .heartRate) else { return }
        
        let query = HKAnchoredObjectQuery(type: heartRateType, predicate: nil, anchor: nil, limit: HKObjectQueryNoLimit) { [weak self] query, samples, deletedObjects, anchor, error in
            self?.processHeartRateSamples(samples, completion: completion)
        }
        
        query.updateHandler = { [weak self] query, samples, deletedObjects, anchor, error in
            self?.processHeartRateSamples(samples, completion: completion)
        }
        
        healthStore.execute(query)
        heartRateQuery = query
    }
    
    func stopHeartRateMonitoring() {
        if let query = heartRateQuery {
            healthStore.stop(query)
            heartRateQuery = nil
        }
    }
    
    private func processHeartRateSamples(_ samples: [HKSample]?, completion: @escaping (Double) -> Void) {
        guard let heartRateSamples = samples as? [HKQuantitySample] else { return }
        
        DispatchQueue.main.async {
            if let lastSample = heartRateSamples.last {
                let heartRateUnit = HKUnit.count().unitDivided(by: .minute())
                let heartRate = lastSample.quantity.doubleValue(for: heartRateUnit)
                self.heartRate = Int(heartRate)
                completion(heartRate)
            }
        }
    }
    
    // MARK: - HRV监测
    func startHRVMonitoring(completion: @escaping (Double) -> Void) {
        guard let hrvType = HKObjectType.quantityType(forIdentifier: .heartRateVariabilitySDNN) else { return }
        
        let query = HKAnchoredObjectQuery(type: hrvType, predicate: nil, anchor: nil, limit: HKObjectQueryNoLimit) { [weak self] query, samples, deletedObjects, anchor, error in
            self?.processHRVSamples(samples, completion: completion)
        }
        
        query.updateHandler = { [weak self] query, samples, deletedObjects, anchor, error in
            self?.processHRVSamples(samples, completion: completion)
        }
        
        healthStore.execute(query)
        hrvQuery = query
    }
    
    func stopHRVMonitoring() {
        if let query = hrvQuery {
            healthStore.stop(query)
            hrvQuery = nil
        }
    }
    
    private func processHRVSamples(_ samples: [HKSample]?, completion: @escaping (Double) -> Void) {
        guard let hrvSamples = samples as? [HKQuantitySample] else { return }
        
        DispatchQueue.main.async {
            if let lastSample = hrvSamples.last {
                let hrvUnit = HKUnit.secondUnit(with: .milli)
                let hrv = lastSample.quantity.doubleValue(for: hrvUnit)
                self.heartRateVariability = hrv
                completion(hrv)
            }
        }
    }
    
    // MARK: - 获取当前HRV
    func getCurrentHRV(completion: @escaping (Double) -> Void) {
        guard let hrvType = HKObjectType.quantityType(forIdentifier: .heartRateVariabilitySDNN) else {
            completion(0)
            return
        }
        
        let query = HKSampleQuery(sampleType: hrvType, predicate: nil, limit: 1, sortDescriptors: [NSSortDescriptor(key: HKSampleSortIdentifierEndDate, ascending: false)]) { _, samples, _ in
            guard let sample = samples?.first as? HKQuantitySample else {
                completion(0)
                return
            }
            
            let hrvUnit = HKUnit.secondUnit(with: .milli)
            let hrv = sample.quantity.doubleValue(for: hrvUnit)
            completion(hrv)
        }
        
        healthStore.execute(query)
    }
    
    // MARK: - 获取指定时间段步数
    func getSteps(from startDate: Date, to endDate: Date, completion: @escaping (Int) -> Void) {
        guard let stepType = HKObjectType.quantityType(forIdentifier: .stepCount) else {
            completion(0)
            return
        }
        
        let predicate = HKQuery.predicateForSamples(withStart: startDate, end: endDate, options: .strictStartDate)
        
        let query = HKStatisticsQuery(quantityType: stepType, quantitySamplePredicate: predicate, options: .cumulativeSum) { _, result, _ in
            guard let result = result, let sum = result.sumQuantity() else {
                completion(0)
                return
            }
            
            let steps = Int(sum.doubleValue(for: HKUnit.count()))
            completion(steps)
        }
        
        healthStore.execute(query)
    }
    
    private func startHeartRateUpdates() {
        guard let heartRateType = HKObjectType.quantityType(forIdentifier: .heartRate) else { 
            print("无法获取心率数据类型")
            return 
        }
        
        // 先获取最新的心率数据
        let latestQuery = HKSampleQuery(sampleType: heartRateType, predicate: nil, limit: 1, sortDescriptors: [NSSortDescriptor(key: HKSampleSortIdentifierEndDate, ascending: false)]) { [weak self] _, samples, _ in
            if let sample = samples?.first as? HKQuantitySample {
                let heartRateUnit = HKUnit.count().unitDivided(by: .minute())
                let heartRate = sample.quantity.doubleValue(for: heartRateUnit)
                DispatchQueue.main.async {
                    self?.heartRate = Int(heartRate)
                    print("获取到最新心率: \(Int(heartRate)) BPM")
                }
            }
        }
        healthStore.execute(latestQuery)
        
        // 设置实时心率监测
        let query = HKAnchoredObjectQuery(type: heartRateType, predicate: nil, anchor: nil, limit: HKObjectQueryNoLimit) { [weak self] query, samples, deletedObjects, anchor, error in
            self?.processHeartRateSamples(samples) { _ in }
        }
        
        query.updateHandler = { [weak self] query, samples, deletedObjects, anchor, error in
            self?.processHeartRateSamples(samples) { _ in }
        }
        
        healthStore.execute(query)
        heartRateQuery = query
    }
    
    private func fetchTodayData() {
        let calendar = Calendar.current
        let now = Date()
        let startOfDay = calendar.startOfDay(for: now)
        let predicate = HKQuery.predicateForSamples(withStart: startOfDay, end: now, options: .strictStartDate)
        
        print("开始获取今日数据，时间范围: \(startOfDay) 到 \(now)")
        
        fetchQuantityData(for: .activeEnergyBurned, unit: .kilocalorie(), predicate: predicate) { [weak self] value in
            DispatchQueue.main.async {
                self?.activeEnergy = value
                print("获取到今日消耗卡路里: \(value)")
            }
        }
        
        fetchQuantityData(for: .stepCount, unit: .count(), predicate: predicate) { [weak self] value in
            DispatchQueue.main.async {
                self?.steps = Int(value)
                print("获取到今日步数: \(Int(value))")
                // 强制更新UI
                self?.objectWillChange.send()
            }
        }
        
        fetchQuantityData(for: .distanceWalkingRunning, unit: .meter(), predicate: predicate) { [weak self] value in
            DispatchQueue.main.async {
                self?.distance = value
            }
        }
        
        fetchQuantityData(for: .flightsClimbed, unit: .count(), predicate: predicate) { [weak self] value in
            DispatchQueue.main.async {
                self?.flightsClimbed = Int(value)
            }
        }
        
        fetchQuantityData(for: .appleExerciseTime, unit: .minute(), predicate: predicate) { [weak self] value in
            DispatchQueue.main.async {
                self?.exerciseTime = Int(value)
            }
        }
        
        fetchQuantityData(for: .appleStandTime, unit: .hour(), predicate: predicate) { [weak self] value in
            DispatchQueue.main.async {
                self?.standHours = Int(value)
            }
        }
        
        fetchQuantityData(for: .vo2Max, unit: HKUnit.literUnit(with: .milli).unitDivided(by: .gramUnit(with: .kilo)).unitDivided(by: .minute()), predicate: predicate) { [weak self] value in
            DispatchQueue.main.async {
                self?.vo2Max = value
            }
        }
        
        fetchQuantityData(for: .restingHeartRate, unit: HKUnit.count().unitDivided(by: .minute()), predicate: predicate) { [weak self] value in
            DispatchQueue.main.async {
                self?.restingHeartRate = Int(value)
                print("获取到今日静息心率: \(Int(value)) BPM")
                // 强制更新UI
                self?.objectWillChange.send()
            }
        }
        
        fetchQuantityData(for: .walkingHeartRateAverage, unit: HKUnit.count().unitDivided(by: .minute()), predicate: predicate) { [weak self] value in
            DispatchQueue.main.async {
                self?.walkingHeartRate = Int(value)
            }
        }
        
        fetchQuantityData(for: .heartRateVariabilitySDNN, unit: .secondUnit(with: .milli), predicate: predicate) { [weak self] value in
            DispatchQueue.main.async {
                self?.heartRateVariability = value
                print("获取到今日心率变异性: \(value)ms")
                // 强制更新UI
                self?.objectWillChange.send()
            }
        }
        
        fetchQuantityData(for: .oxygenSaturation, unit: .percent(), predicate: predicate) { [weak self] value in
            DispatchQueue.main.async {
                self?.bloodOxygen = value * 100
            }
        }
        
        fetchQuantityData(for: .bodyTemperature, unit: .degreeCelsius(), predicate: predicate) { [weak self] value in
            DispatchQueue.main.async {
                self?.bodyTemperature = value
            }
        }
        
        fetchQuantityData(for: .respiratoryRate, unit: HKUnit.count().unitDivided(by: .minute()), predicate: predicate) { [weak self] value in
            DispatchQueue.main.async {
                self?.respiratoryRate = value
            }
        }
        
        fetchSleepAnalysis(predicate: predicate)
        
        // 获取当前心率（不是今日平均）
        fetchCurrentHeartRate()
        
        // 延迟刷新数据，确保所有数据都已获取
        DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {
            self.objectWillChange.send()
        }
    }
    
    private func fetchQuantityData(for identifier: HKQuantityTypeIdentifier, unit: HKUnit, predicate: NSPredicate, completion: @escaping (Double) -> Void) {
        guard let quantityType = HKQuantityType.quantityType(forIdentifier: identifier) else {
            print("无法获取数据类型: \(identifier)")
            completion(0)
            return
        }
        
        // 确定使用哪种统计选项
        let options: HKStatisticsOptions
        switch identifier {
        case .vo2Max, .restingHeartRate, .walkingHeartRateAverage, .heartRateVariabilitySDNN, .oxygenSaturation, .bodyTemperature, .respiratoryRate:
            // 离散数据使用平均值
            options = .discreteAverage
        default:
            // 累积数据使用累积和
            options = .cumulativeSum
        }
        
        let query = HKStatisticsQuery(quantityType: quantityType, quantitySamplePredicate: predicate, options: options) { _, result, error in
            if let error = error {
                print("数据查询错误 \(identifier): \(error)")
                completion(0)
                return
            }
            
            if options == .discreteAverage {
                guard let result = result, let average = result.averageQuantity() else {
                    print("无法获取平均值: \(identifier)")
                    completion(0)
                    return
                }
                let value = average.doubleValue(for: unit)
                print("获取到平均值 \(identifier): \(value)")
                completion(value)
            } else {
                guard let result = result, let sum = result.sumQuantity() else {
                    print("无法获取累积值: \(identifier)")
                    completion(0)
                    return
                }
                let value = sum.doubleValue(for: unit)
                print("获取到累积值 \(identifier): \(value)")
                completion(value)
            }
        }
        
        healthStore.execute(query)
    }
    
    private func fetchSleepAnalysis(predicate: NSPredicate) {
        guard let sleepType = HKObjectType.categoryType(forIdentifier: .sleepAnalysis) else { 
            print("无法获取睡眠数据类型")
            DispatchQueue.main.async {
                self.sleepAnalysis = "暂无数据"
            }
            return 
        }
        
        print("开始查询睡眠数据...")
        
        let query = HKSampleQuery(sampleType: sleepType, predicate: predicate, limit: HKObjectQueryNoLimit, sortDescriptors: [NSSortDescriptor(key: HKSampleSortIdentifierEndDate, ascending: false)]) { [weak self] _, samples, error in
            if let error = error {
                print("睡眠数据查询错误: \(error)")
                DispatchQueue.main.async {
                    self?.sleepAnalysis = "查询错误"
                }
                return
            }
            
            print("睡眠数据查询完成，样本数量: \(samples?.count ?? 0)")
            
            guard let sleepSamples = samples as? [HKCategorySample], !sleepSamples.isEmpty else {
                print("没有找到睡眠数据样本")
                DispatchQueue.main.async {
                    self?.sleepAnalysis = "暂无数据"
                }
                return
            }
            
            print("找到 \(sleepSamples.count) 个睡眠样本")
            
            var totalSleepTime: TimeInterval = 0
            for sample in sleepSamples {
                print("睡眠样本: \(sample.startDate) - \(sample.endDate), 类型: \(sample.value)")
                if sample.value == HKCategoryValueSleepAnalysis.inBed.rawValue || sample.value == HKCategoryValueSleepAnalysis.asleep.rawValue {
                    let duration = sample.endDate.timeIntervalSince(sample.startDate)
                    totalSleepTime += duration
                    print("添加睡眠时间: \(duration/3600) 小时")
                }
            }
            
            let hours = Int(totalSleepTime / 3600)
            let minutes = Int((totalSleepTime.truncatingRemainder(dividingBy: 3600)) / 60)
            
            print("总睡眠时间: \(totalSleepTime/3600) 小时, 格式化: \(hours)h \(minutes)m")
            
            DispatchQueue.main.async {
                if totalSleepTime > 0 {
                    self?.sleepAnalysis = "\(hours)h \(minutes)m"
                } else {
                    self?.sleepAnalysis = "暂无数据"
                }
                // 强制更新UI
                self?.objectWillChange.send()
            }
        }
        
        healthStore.execute(query)
    }
    
    // MARK: - 获取当前心率
    private func fetchCurrentHeartRate() {
        guard let heartRateType = HKObjectType.quantityType(forIdentifier: .heartRate) else { 
            print("无法获取心率数据类型")
            return 
        }
        
        let query = HKSampleQuery(sampleType: heartRateType, predicate: nil, limit: 1, sortDescriptors: [NSSortDescriptor(key: HKSampleSortIdentifierEndDate, ascending: false)]) { [weak self] _, samples, _ in
            if let sample = samples?.first as? HKQuantitySample {
                let heartRateUnit = HKUnit.count().unitDivided(by: .minute())
                let heartRate = sample.quantity.doubleValue(for: heartRateUnit)
                DispatchQueue.main.async {
                    self?.heartRate = Int(heartRate)
                    print("获取到当前心率: \(Int(heartRate)) BPM")
                    // 强制更新UI
                    self?.objectWillChange.send()
                }
            } else {
                print("未找到心率数据")
            }
        }
        
        healthStore.execute(query)
    }
} 
----

----
FilePath: ming-ling-watch-os Watch App/Managers/LocationManager.swift
Lines: 84
//
//  LocationManager.swift
//  test-app Watch App
//
//  Created by CreepOnSky on 2025/7/24.
//

import Foundation
import CoreLocation
import WatchKit

class LocationManager: NSObject, ObservableObject, CLLocationManagerDelegate {
    private let locationManager = CLLocationManager()
    
    @Published var latitude: Double = 0
    @Published var longitude: Double = 0
    @Published var altitude: Double = 0
    @Published var speed: Double = 0
    @Published var course: Double = 0
    @Published var accuracy: Double = 0
    @Published var isAuthorized = false
    
    override init() {
        super.init()
        locationManager.delegate = self
        locationManager.desiredAccuracy = kCLLocationAccuracyBest
        locationManager.distanceFilter = 1.0
        checkAuthorizationStatus()
    }
    
    func requestAuthorization() {
        locationManager.requestWhenInUseAuthorization()
    }
    
    private func checkAuthorizationStatus() {
        switch locationManager.authorizationStatus {
        case .authorizedWhenInUse, .authorizedAlways:
            isAuthorized = true
            startLocationUpdates()
        default:
            isAuthorized = false
        }
    }
    
    private func startLocationUpdates() {
        locationManager.startUpdatingLocation()
    }
    
    func stopLocationUpdates() {
        locationManager.stopUpdatingLocation()
    }
    
    // MARK: - CLLocationManagerDelegate
    
    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
        guard let location = locations.last else { return }
        
        DispatchQueue.main.async {
            self.latitude = location.coordinate.latitude
            self.longitude = location.coordinate.longitude
            self.altitude = location.altitude
            self.speed = location.speed
            self.course = location.course
            self.accuracy = location.horizontalAccuracy
        }
    }
    
    func locationManager(_ manager: CLLocationManager, didFailWithError error: Error) {
        print("Location manager failed with error: \(error.localizedDescription)")
    }
    
    func locationManager(_ manager: CLLocationManager, didChangeAuthorization status: CLAuthorizationStatus) {
        DispatchQueue.main.async {
            switch status {
            case .authorizedWhenInUse, .authorizedAlways:
                self.isAuthorized = true
                self.startLocationUpdates()
            default:
                self.isAuthorized = false
                self.stopLocationUpdates()
            }
        }
    }
} 
----

----
FilePath: ming-ling-watch-os Watch App/Managers/MotionManager.swift
Lines: 259
//
//  MotionManager.swift
//  test-app Watch App
//
//  Created by CreepOnSky on 2025/7/24.
//

import Foundation
import CoreMotion
import WatchKit

struct Vector3D {
    var x: Double = 0
    var y: Double = 0
    var z: Double = 0
}

struct DeviceMotionData {
    var roll: Double = 0
    var pitch: Double = 0
    var yaw: Double = 0
}

class MotionManager: NSObject, ObservableObject {
    private let motionManager = CMMotionManager()
    private let pedometer = CMPedometer()
    private let activityManager = CMMotionActivityManager()
    
    @Published var accelerometerData = Vector3D()
    @Published var gyroscopeData = Vector3D()
    @Published var magnetometerData = Vector3D()
    @Published var deviceMotion = DeviceMotionData()
    @Published var gravity = Vector3D()
    @Published var userAcceleration = Vector3D()
    @Published var rotationRate = Vector3D()
    @Published var magneticField = Vector3D()
    @Published var magneticFieldAccuracy: String = "Unknown"
    
    @Published var barometricPressure: Double = 0
    @Published var temperature: Double = 0
    @Published var humidity: Double = 0
    
    @Published var currentActivity: String = "Unknown"
    @Published var activityConfidence: Int = 0
    @Published var pedometerSteps: Int = 0
    @Published var pedometerDistance: Double = 0
    @Published var pedometerFloorsAscended: Int = 0
    @Published var pedometerFloorsDescended: Int = 0
    @Published var pedometerCadence: Double = 0
    @Published var pedometerAverageActivePace: Double = 0
    
    private var isUpdating = false
    private var stepCountingCallback: ((Int) -> Void)?
    
    override init() {
        super.init()
        setupMotionManager()
    }
    
    private func setupMotionManager() {
        motionManager.accelerometerUpdateInterval = 0.1
        motionManager.gyroUpdateInterval = 0.1
        motionManager.magnetometerUpdateInterval = 0.1
        motionManager.deviceMotionUpdateInterval = 0.1
    }
    
    // MARK: - 步数监测
    func startStepCounting(callback: @escaping (Int) -> Void) {
        stepCountingCallback = callback
        
        guard CMPedometer.isStepCountingAvailable() else {
            print("步数监测不可用")
            return
        }
        
        let startDate = Calendar.current.startOfDay(for: Date())
        
        pedometer.startUpdates(from: startDate) { [weak self] data, error in
            guard let data = data else { return }
            
            DispatchQueue.main.async {
                let steps = data.numberOfSteps.intValue
                self?.pedometerSteps = steps
                self?.pedometerDistance = data.distance?.doubleValue ?? 0
                self?.pedometerFloorsAscended = data.floorsAscended?.intValue ?? 0
                self?.pedometerFloorsDescended = data.floorsDescended?.intValue ?? 0
                self?.pedometerCadence = data.currentCadence?.doubleValue ?? 0
                self?.pedometerAverageActivePace = data.averageActivePace?.doubleValue ?? 0
                
                // 调用回调函数
                self?.stepCountingCallback?(steps)
            }
        }
    }
    
    func stopStepCounting() {
        pedometer.stopUpdates()
        stepCountingCallback = nil
    }
    
    func startUpdates() {
        guard !isUpdating else { return }
        isUpdating = true
        
        startAccelerometerUpdates()
        startGyroscopeUpdates()
        startMagnetometerUpdates()
        startDeviceMotionUpdates()
        startPedometerUpdates()
        startActivityUpdates()
        updateEnvironmentalData()
    }
    
    func stopUpdates() {
        isUpdating = false
        motionManager.stopAccelerometerUpdates()
        motionManager.stopGyroUpdates()
        motionManager.stopMagnetometerUpdates()
        motionManager.stopDeviceMotionUpdates()
        activityManager.stopActivityUpdates()
    }
    
    private func startAccelerometerUpdates() {
        guard motionManager.isAccelerometerAvailable else { return }
        
        motionManager.startAccelerometerUpdates(to: .main) { [weak self] data, error in
            guard let data = data else { return }
            
            DispatchQueue.main.async {
                self?.accelerometerData.x = data.acceleration.x
                self?.accelerometerData.y = data.acceleration.y
                self?.accelerometerData.z = data.acceleration.z
            }
        }
    }
    
    private func startGyroscopeUpdates() {
        guard motionManager.isGyroAvailable else { return }
        
        motionManager.startGyroUpdates(to: .main) { [weak self] data, error in
            guard let data = data else { return }
            
            DispatchQueue.main.async {
                self?.gyroscopeData.x = data.rotationRate.x
                self?.gyroscopeData.y = data.rotationRate.y
                self?.gyroscopeData.z = data.rotationRate.z
            }
        }
    }
    
    private func startMagnetometerUpdates() {
        guard motionManager.isMagnetometerAvailable else { return }
        
        motionManager.startMagnetometerUpdates(to: .main) { [weak self] data, error in
            guard let data = data else { return }
            
            DispatchQueue.main.async {
                self?.magnetometerData.x = data.magneticField.x
                self?.magnetometerData.y = data.magneticField.y
                self?.magnetometerData.z = data.magneticField.z
                
                // CMMagneticField没有accuracy属性，使用固定值
                self?.magneticFieldAccuracy = "Medium"
            }
        }
    }
    
    private func startDeviceMotionUpdates() {
        guard motionManager.isDeviceMotionAvailable else { return }
        
        motionManager.startDeviceMotionUpdates(to: .main) { [weak self] data, error in
            guard let data = data else { return }
            
            DispatchQueue.main.async {
                self?.deviceMotion.roll = data.attitude.roll
                self?.deviceMotion.pitch = data.attitude.pitch
                self?.deviceMotion.yaw = data.attitude.yaw
                
                self?.gravity.x = data.gravity.x
                self?.gravity.y = data.gravity.y
                self?.gravity.z = data.gravity.z
                
                self?.userAcceleration.x = data.userAcceleration.x
                self?.userAcceleration.y = data.userAcceleration.y
                self?.userAcceleration.z = data.userAcceleration.z
                
                self?.rotationRate.x = data.rotationRate.x
                self?.rotationRate.y = data.rotationRate.y
                self?.rotationRate.z = data.rotationRate.z
                
                self?.magneticField.x = data.magneticField.field.x
                self?.magneticField.y = data.magneticField.field.y
                self?.magneticField.z = data.magneticField.field.z
            }
        }
    }
    
    private func startPedometerUpdates() {
        guard CMPedometer.isStepCountingAvailable() else { return }
        
        let startDate = Calendar.current.startOfDay(for: Date())
        
        pedometer.startUpdates(from: startDate) { [weak self] data, error in
            guard let data = data else { return }
            
            DispatchQueue.main.async {
                self?.pedometerSteps = data.numberOfSteps.intValue
                self?.pedometerDistance = data.distance?.doubleValue ?? 0
                self?.pedometerFloorsAscended = data.floorsAscended?.intValue ?? 0
                self?.pedometerFloorsDescended = data.floorsDescended?.intValue ?? 0
                self?.pedometerCadence = data.currentCadence?.doubleValue ?? 0
                self?.pedometerAverageActivePace = data.averageActivePace?.doubleValue ?? 0
            }
        }
    }
    
    private func startActivityUpdates() {
        guard CMMotionActivityManager.isActivityAvailable() else { return }
        
        activityManager.startActivityUpdates(to: .main) { [weak self] activity in
            guard let activity = activity else { return }
            
            DispatchQueue.main.async {
                var activityString = "Unknown"
                
                if activity.walking {
                    activityString = "Walking"
                } else if activity.running {
                    activityString = "Running"
                } else if activity.automotive {
                    activityString = "Automotive"
                } else if activity.cycling {
                    activityString = "Cycling"
                } else if activity.stationary {
                    activityString = "Stationary"
                }
                
                self?.currentActivity = activityString
                self?.activityConfidence = Int(activity.confidence.rawValue * 100)
            }
        }
    }
    
    // 模拟环境数据（实际Apple Watch可能不提供这些数据）
    private func updateEnvironmentalData() {
        // 这些数据在实际Apple Watch上可能不可用
        // 这里只是示例实现
        DispatchQueue.main.async {
            self.barometricPressure = 1013.25 + Double.random(in: -10...10) // 标准大气压 ± 变化
            self.temperature = 20.0 + Double.random(in: -5...5) // 室温 ± 变化
            self.humidity = 50.0 + Double.random(in: -10...10) // 相对湿度 ± 变化
        }
        
        // 定期更新环境数据
        DispatchQueue.main.asyncAfter(deadline: .now() + 5.0) { [weak self] in
            self?.updateEnvironmentalData()
        }
    }
} 
----

----
FilePath: ming-ling-watch-os Watch App/Models/BaziData.swift
Lines: 101
import Foundation

// MARK: - 八字数据模型
struct BaziData: Codable {
    let base_info: BaseInfo
    let bazi_info: BaziInfo
    let chenggu: ChengguInfo
    let wuxing: WuxingInfo
    let yinyuan: YinyuanInfo?
    let caiyun: CaiyunInfo?
    let sizhu: SizhuInfo?
    let mingyun: MingyunInfo?
    let sx: String
    let xz: String
    let xiyongshen: XiyongshenInfo
}

struct BaseInfo: Codable {
    let sex: String
    let name: String
    let gongli: String
    let nongli: String
    let qiyun: String
    let jiaoyun: String
    let zhengge: String
    let wuxing_xiji: String
}

struct BaziInfo: Codable {
    let kw: String
    let tg_cg_god: [String]
    let bazi: String
    let na_yin: String
}

struct ChengguInfo: Codable {
    let year_weight: String
    let month_weight: String
    let day_weight: String
    let hour_weight: String
    let total_weight: String
    let description: String
}

struct WuxingInfo: Codable {
    let detail_desc: String
    let simple_desc: String
    let simple_description: String
    let detail_description: String
}

struct YinyuanInfo: Codable {
    let sanshishu_yinyuan: String
}

struct CaiyunInfo: Codable {
    let sanshishu_caiyun: SanshishuCaiyun
}

struct SanshishuCaiyun: Codable {
    let simple_desc: String
    let detail_desc: String
}

struct SizhuInfo: Codable {
    let rizhu: String
}

struct MingyunInfo: Codable {
    let sanshishu_mingyun: String
}

struct XiyongshenInfo: Codable {
    let qiangruo: String
    let xiyongshen: String
    let jishen: String
    let xiyongshen_desc: String
    let jin_number: Int
    let mu_number: Int
    let shui_number: Int
    let huo_number: Int
    let tu_number: Int
    let tonglei: String
    let yilei: String
    let rizhu_tiangan: String
    let zidang: Int
    let yidang: Int
    let zidang_percent: String
    let yidang_percent: String
    let jin_score: Int
    let mu_score: Int
    let shui_score: Int
    let huo_score: Int
    let tu_score: Int
    let jin_score_percent: String
    let mu_score_percent: String
    let shui_score_percent: String
    let huo_score_percent: String
    let tu_score_percent: String
    let yinyang: String
} 
----

----
FilePath: ming-ling-watch-os Watch App/Models/HealthReminders.swift
Lines: 147
import Foundation

// MARK: - 健康提醒模型
struct HealthReminder: Codable, Identifiable {
    let id = UUID()
    let type: ReminderType
    let trigger: TriggerCondition
    
    var title: String {
        return type.rawValue
    }
    
    var description: String {
        switch type {
        case .sunExposure:
            return "适当晒太阳有助于维生素D合成"
        case .stress:
            return "监测压力水平，保持心理健康"
        case .sedentary:
            return "久坐提醒，适时活动身体"
        case .exercise:
            return "运动心率监测，确保运动效果"
        case .sleep:
            return "睡眠质量监测，保证充足休息"
        }
    }
    
    var icon: String {
        return type.icon
    }
    
    enum ReminderType: String, Codable, CaseIterable {
        case sunExposure = "晒太阳"
        case stress = "压力大"
        case sedentary = "久坐"
        case exercise = "运动检测"
        case sleep = "睡眠监测"
        
        var icon: String {
            switch self {
            case .sunExposure: return "sun.max.fill"
            case .stress: return "brain.head.profile"
            case .sedentary: return "figure.seated.seatbelt"
            case .exercise: return "figure.run"
            case .sleep: return "bed.double.fill"
            }
        }
        
        var color: String {
            switch self {
            case .sunExposure: return "#FF8C00"
            case .stress: return "#9370DB"
            case .sedentary: return "#4169E1"
            case .exercise: return "#32CD32"
            case .sleep: return "#4B0082"
            }
        }
        
        // 转换为TaskType
        var taskType: TaskType {
            switch self {
            case .sunExposure: return .sunExposure
            case .stress: return .stress
            case .sedentary: return .sedentary
            case .exercise: return .exercise
            case .sleep: return .sleep
            }
        }
    }
}

// MARK: - 触发条件
struct TriggerCondition: Codable {
    let conditions: [String]
    let detection: [String]
}

// MARK: - 健康提醒数据
extension HealthReminder {
    static let allReminders: [HealthReminder] = [
        // 晒太阳提醒
        HealthReminder(
            type: .sunExposure,
            trigger: TriggerCondition(
                conditions: [
                    "UV指数2-6（适中）",
                    "时辰：上午9-11点或下午3-5点",
                    "室内超过2小时"
                ],
                detection: [
                    "光线传感器检测到环境光变化",
                    "GPS从室内到室外（建筑物外面）",
                    "UV指数API"
                ]
            )
        ),
        
        // 压力提醒
        HealthReminder(
            type: .stress,
            trigger: TriggerCondition(
                conditions: ["HRV持续低于个人基线20%"],
                detection: ["Apple Watch HRV数据"]
            )
        ),
        
        // 久坐提醒
        HealthReminder(
            type: .sedentary,
            trigger: TriggerCondition(
                conditions: ["1小时内步数<40步"],
                detection: ["Apple Watch活动监测"]
            )
        ),
        
        // 运动检测
        HealthReminder(
            type: .exercise,
            trigger: TriggerCondition(
                conditions: ["心率持续>120超过10分钟"],
                detection: ["Apple Watch心率"]
            )
        ),
        
        // 睡眠监测
        HealthReminder(
            type: .sleep,
            trigger: TriggerCondition(
                conditions: ["早上检测到前晚睡眠<7小时"],
                detection: ["Apple Watch睡眠数据"]
            )
        )
    ]
    
    // 根据五行属性获取建议内容
    func getSuggestionContent(for element: String) -> String? {
        return ReminderContentManager.shared.getSuggestionContent(for: type.taskType, element: element)?.message
    }
    
    // 根据五行属性获取完成内容
    func getCompletionContent(for element: String) -> (message: String, intimacyPoints: Int)? {
        guard let completion = ReminderContentManager.shared.getCompletionContent(for: type.taskType, element: element) else {
            return nil
        }
        return (completion.message, completion.intimacyPoints)
    }
} 
----

----
FilePath: ming-ling-watch-os Watch App/Models/UserProfile.swift
Lines: 137
import Foundation

// MARK: - 用户档案模型
struct UserProfile: Codable {
    var birthday: Date?
    var sex: Int = 0 // 0男 1女
    var fiveElements: FiveElements?
    var baziData: BaziData?
    var petRecommendation: String?
    var healthStreak: Int = 0
    var lastHealthCheck: Date?
    
    // 亲密值系统
    var intimacyLevel: Int = 0 // 0-100
    var intimacyPoints: Int = 0 // 累计积分
    
    // 亲密值等级
    var intimacyGrade: Int {
        if intimacyLevel >= 80 {
            return 3 // 亲密
        } else if intimacyLevel >= 50 {
            return 2 // 友好
        } else {
            return 1 // 陌生
        }
    }
    
    // 亲密值等级名称
    var intimacyGradeName: String {
        switch intimacyGrade {
        case 3:
            return "亲密"
        case 2:
            return "友好"
        case 1:
            return "陌生"
        default:
            return "陌生"
        }
    }
    
    // 亲密值等级图标
    var intimacyGradeIcon: String {
        switch intimacyGrade {
        case 3:
            return "heart.fill"
        case 2:
            return "heart"
        case 1:
            return "heart.slash"
        default:
            return "heart.slash"
        }
    }
    
    // 亲密值等级颜色
    var intimacyGradeColor: String {
        switch intimacyGrade {
        case 3:
            return "#FF6B6B" // 红色
        case 2:
            return "#FFB347" // 橙色
        case 1:
            return "#87CEEB" // 蓝色
        default:
            return "#87CEEB"
        }
    }
    
    // 增加亲密值
    mutating func addIntimacy(_ points: Int) {
        intimacyPoints += points
        intimacyLevel = min(100, intimacyLevel + points)
    }
    
    // 减少亲密值
    mutating func reduceIntimacy(_ points: Int) {
        intimacyLevel = max(0, intimacyLevel - points)
    }
    
    // 获取亲密值进度百分比
    var intimacyProgress: Double {
        return Double(intimacyLevel) / 100.0
    }
    
    // 获取下一等级所需积分
    var pointsToNextGrade: Int {
        switch intimacyGrade {
        case 1:
            return max(0, 50 - intimacyLevel)
        case 2:
            return max(0, 80 - intimacyLevel)
        case 3:
            return 0 // 已经是最高等级
        default:
            return 0
        }
    }
    
    // 更新健康天数
    mutating func updateHealthStreak() {
        let calendar = Calendar.current
        let today = Date()
        
        if let lastCheck = lastHealthCheck {
            let daysSinceLastCheck = calendar.dateComponents([.day], from: lastCheck, to: today).day ?? 0
            
            if daysSinceLastCheck == 1 {
                // 连续天数
                healthStreak += 1
            } else if daysSinceLastCheck > 1 {
                // 中断了，重置为1
                healthStreak = 1
            }
        } else {
            // 第一次检查
            healthStreak = 1
        }
        
        lastHealthCheck = today
    }
}

// MARK: - 五行属性模型
struct FiveElements: Codable {
    let primary: String
    let secondary: String
    let tertiary: String
    let description: String
    
    init(primary: String, secondary: String, tertiary: String, description: String) {
        self.primary = primary
        self.secondary = secondary
        self.tertiary = tertiary
        self.description = description
    }
} 
----

----
FilePath: ming-ling-watch-os Watch App/Services/BaziAPIService.swift
Lines: 174
import Foundation

// MARK: - 八字API服务
class BaziAPIService: ObservableObject {
    private let apiKey = "Ta8IUNfPIo9mfkRY0ey4HZJ0O"
    private let baseURL = "https://api.yuanfenju.com/index.php/v1/Bazi/cesuan"
    
    @Published var isLoading = false
    @Published var error: String?
    
    // MARK: - API响应模型
    struct BaziResponse: Codable {
        let errcode: Int
        let errmsg: String
        let notice: String?
        let data: BaziData?
    }
    
    // MARK: - 获取五行属性
    func getFiveElements(birthday: Date, sex: Int) async throws -> (FiveElements, BaziData) {
        await MainActor.run {
            isLoading = true
            error = nil
        }
        
        defer {
            Task { @MainActor in
                isLoading = false
            }
        }
        
        let calendar = Calendar.current
        let year = calendar.component(.year, from: birthday)
        let month = calendar.component(.month, from: birthday)
        let day = calendar.component(.day, from: birthday)
        let hour = calendar.component(.hour, from: birthday)
        let minute = calendar.component(.minute, from: birthday)
        
        let url = URL(string: baseURL)!
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/x-www-form-urlencoded", forHTTPHeaderField: "Content-Type")
        
        // 构建表单数据
        var components = URLComponents()
        components.queryItems = [
            URLQueryItem(name: "api_key", value: apiKey),
            URLQueryItem(name: "name", value: "用户"),
            URLQueryItem(name: "sex", value: "\(sex)"),
            URLQueryItem(name: "type", value: "1"), // 公历
            URLQueryItem(name: "year", value: "\(year)"),
            URLQueryItem(name: "month", value: "\(month)"),
            URLQueryItem(name: "day", value: "\(day)"),
            URLQueryItem(name: "hours", value: "\(hour)"),
            URLQueryItem(name: "minute", value: "\(minute)"),
            URLQueryItem(name: "zhen", value: "2"), // 不考虑真太阳时
            URLQueryItem(name: "lang", value: "zh-cn")
        ]
        
        request.httpBody = components.query?.data(using: .utf8)
        
        let (data, response) = try await URLSession.shared.data(for: request)
        
        guard let httpResponse = response as? HTTPURLResponse else {
            throw APIError.invalidResponse
        }
        
        guard httpResponse.statusCode == 200 else {
            throw APIError.httpError(httpResponse.statusCode)
        }
        
        let baziResponse = try JSONDecoder().decode(BaziResponse.self, from: data)
        
        guard baziResponse.errcode == 0, let baziData = baziResponse.data else {
            throw APIError.apiError(baziResponse.errmsg)
        }
        
        // 根据喜用神确定五行属性
        let primaryElement = determinePrimaryElement(xiyong: baziData.xiyongshen.xiyongshen)
        
        // 创建FiveElements实例
        let fiveElements = createFiveElements(for: primaryElement)
        
        return (fiveElements, baziData)
    }
    
    // MARK: - 确定主属性
    private func determinePrimaryElement(xiyong: String) -> String {
        // 根据喜用神字符串判断主属性
        if xiyong.contains("金") {
            return "金"
        } else if xiyong.contains("木") {
            return "木"
        } else if xiyong.contains("水") {
            return "水"
        } else if xiyong.contains("火") {
            return "火"
        } else if xiyong.contains("土") {
            return "土"
        }
        
        // 默认返回金
        return "金"
    }
    
    // MARK: - 创建五行属性
    private func createFiveElements(for primaryElement: String) -> FiveElements {
        switch primaryElement {
        case "金":
            return FiveElements(
                primary: "金",
                secondary: "水",
                tertiary: "土",
                description: "金主肺气，喜清润"
            )
        case "木":
            return FiveElements(
                primary: "木",
                secondary: "火",
                tertiary: "水",
                description: "木主肝气，喜舒展"
            )
        case "水":
            return FiveElements(
                primary: "水",
                secondary: "木",
                tertiary: "金",
                description: "水主肾气，喜温润"
            )
        case "火":
            return FiveElements(
                primary: "火",
                secondary: "土",
                tertiary: "木",
                description: "火主心气，喜清凉"
            )
        case "土":
            return FiveElements(
                primary: "土",
                secondary: "金",
                tertiary: "火",
                description: "土主脾气，喜温和"
            )
        default:
            return FiveElements(
                primary: "金",
                secondary: "水",
                tertiary: "土",
                description: "金主肺气，喜清润"
            )
        }
    }
}

// MARK: - API错误
enum APIError: Error, LocalizedError {
    case invalidResponse
    case httpError(Int)
    case apiError(String)
    case networkError
    
    var errorDescription: String? {
        switch self {
        case .invalidResponse:
            return "服务器响应无效"
        case .httpError(let code):
            return "HTTP错误: \(code)"
        case .apiError(let message):
            return "API错误: \(message)"
        case .networkError:
            return "网络连接错误"
        }
    }
} 
----

----
FilePath: ming-ling-watch-os Watch App/Services/EnvironmentSensorManager.swift
Lines: 194
import Foundation
import CoreLocation
import WatchKit

// MARK: - 环境传感器管理器
class EnvironmentSensorManager: NSObject, ObservableObject {
    static let shared = EnvironmentSensorManager()
    
    @Published var isIndoor = true
    @Published var ambientLightLevel: Double = 0
    @Published var uvIndex: Double = 0
    @Published var location: CLLocation?
    @Published var authorizationStatus: CLAuthorizationStatus = .notDetermined
    
    private let locationManager = CLLocationManager()
    private let device = WKInterfaceDevice.current()
    
    private override init() {
        super.init()
        setupLocationManager()
        startAmbientLightMonitoring()
    }
    
    // MARK: - 设置位置管理器
    private func setupLocationManager() {
        locationManager.delegate = self
        locationManager.desiredAccuracy = kCLLocationAccuracyBest
        locationManager.distanceFilter = 10 // 10米更新一次
    }
    
    // MARK: - 请求位置权限
    func requestLocationPermission() {
        locationManager.requestWhenInUseAuthorization()
    }
    
    // MARK: - 开始位置监测
    func startLocationMonitoring() {
        guard authorizationStatus == .authorizedWhenInUse || authorizationStatus == .authorizedAlways else {
            requestLocationPermission()
            return
        }
        
        locationManager.startUpdatingLocation()
    }
    
    // MARK: - 停止位置监测
    func stopLocationMonitoring() {
        locationManager.stopUpdatingLocation()
    }
    
    // MARK: - 开始环境光监测
    private func startAmbientLightMonitoring() {
        // 在watchOS中，我们可以通过系统API获取环境光信息
        // 这里使用定时器模拟环境光变化
        Timer.scheduledTimer(withTimeInterval: 60, repeats: true) { _ in
            self.updateAmbientLightLevel()
        }
    }
    
    // MARK: - 更新环境光水平
    private func updateAmbientLightLevel() {
        // 模拟环境光传感器数据
        // 在实际应用中，这里应该从系统API获取真实数据
        let hour = Calendar.current.component(.hour, from: Date())
        
        switch hour {
        case 6..<9:
            // 早晨，光线逐渐增强
            ambientLightLevel = Double.random(in: 0.3...0.7)
        case 9..<17:
            // 白天，光线充足
            ambientLightLevel = Double.random(in: 0.7...1.0)
        case 17..<20:
            // 傍晚，光线逐渐减弱
            ambientLightLevel = Double.random(in: 0.4...0.8)
        default:
            // 夜晚，光线很弱
            ambientLightLevel = Double.random(in: 0.0...0.3)
        }
        
        // 更新UV指数
        updateUVIndex()
    }
    
    // MARK: - 更新UV指数
    private func updateUVIndex() {
        let hour = Calendar.current.component(.hour, from: Date())
        
        // 根据时间和环境光估算UV指数
        if hour >= 10 && hour <= 16 && ambientLightLevel > 0.6 {
            // 白天且光线充足时，UV指数较高
            uvIndex = Double.random(in: 3...8)
        } else if hour >= 9 && hour <= 17 && ambientLightLevel > 0.4 {
            // 适合晒太阳的时间段
            uvIndex = Double.random(in: 2...6)
        } else {
            // 其他时间UV指数较低
            uvIndex = Double.random(in: 0...2)
        }
    }
    
    // MARK: - 检查是否适合晒太阳
    func isGoodTimeForSunExposure() -> Bool {
        let hour = Calendar.current.component(.hour, from: Date())
        let isGoodTime = (hour >= 9 && hour <= 11) || (hour >= 15 && hour <= 17)
        let isGoodUV = uvIndex >= 2 && uvIndex <= 6
        let isGoodLight = ambientLightLevel > 0.5
        
        return isGoodTime && isGoodUV && isGoodLight
    }
    
    // MARK: - 检查是否从室内到室外
    func checkIndoorToOutdoorTransition() -> Bool {
        // 这里应该基于位置变化和环境光变化来判断
        // 简化实现：基于环境光变化
        let lightThreshold: Double = 0.6
        return ambientLightLevel > lightThreshold && isIndoor
    }
    
    // MARK: - 获取环境状态描述
    func getEnvironmentStatus() -> String {
        if isGoodTimeForSunExposure() {
            return "适合晒太阳"
        } else if ambientLightLevel > 0.7 {
            return "环境明亮"
        } else if ambientLightLevel > 0.4 {
            return "光线适中"
        } else {
            return "光线较暗"
        }
    }
    
    // MARK: - 获取UV状态描述
    func getUVStatus() -> String {
        switch uvIndex {
        case 0..<2:
            return "低"
        case 2..<6:
            return "适中"
        case 6..<8:
            return "高"
        default:
            return "很高"
        }
    }
}

// MARK: - CLLocationManagerDelegate
extension EnvironmentSensorManager: CLLocationManagerDelegate {
    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
        guard let location = locations.last else { return }
        
        DispatchQueue.main.async {
            self.location = location
            self.updateIndoorOutdoorStatus(location: location)
        }
    }
    
    func locationManager(_ manager: CLLocationManager, didFailWithError error: Error) {
        print("Location manager failed with error: \(error)")
    }
    
    func locationManager(_ manager: CLLocationManager, didChangeAuthorization status: CLAuthorizationStatus) {
        DispatchQueue.main.async {
            self.authorizationStatus = status
            
            if status == .authorizedWhenInUse || status == .authorizedAlways {
                self.startLocationMonitoring()
            }
        }
    }
    
    // MARK: - 更新室内外状态
    private func updateIndoorOutdoorStatus(location: CLLocation) {
        // 这里应该基于位置信息和环境光来判断室内外状态
        // 简化实现：基于环境光水平
        let wasIndoor = isIndoor
        isIndoor = ambientLightLevel < 0.5
        
        // 如果从室内到室外，触发晒太阳提醒
        if wasIndoor && !isIndoor && isGoodTimeForSunExposure() {
            NotificationCenter.default.post(
                name: .sunExposureOpportunity,
                object: nil,
                userInfo: ["location": location]
            )
        }
    }
}

// MARK: - 通知名称扩展
extension Notification.Name {
    static let sunExposureOpportunity = Notification.Name("sunExposureOpportunity")
} 
----

----
FilePath: ming-ling-watch-os Watch App/Services/HealthMonitoringService.swift
Lines: 462
import Foundation
import HealthKit
import CoreMotion
import CoreLocation
import WatchKit

// MARK: - 健康监测服务
class HealthMonitoringService: ObservableObject {
    static let shared = HealthMonitoringService()
    
    @Published var currentHealthStatus: HealthStatus = .normal
    @Published var lastReminderTime: Date?
    @Published var isMonitoringFollowUp = false
    
    private let healthKitManager = HealthKitManager()
    private let motionManager = MotionManager()
    private let locationManager = LocationManager()
    private let systemNotificationManager = SystemNotificationManager.shared
    private let profileManager = UserProfileManager.shared
    
    // 每日提醒限制
    private var dailyReminderCounts: [TaskType: Int] = [:]
    private var lastResetDate: Date?
    
    // 久坐检测相关
    private var sedentaryReminderSent = false
    private var sedentaryReminderTime: Date?
    private var stepsBeforeReminder = 0
    private var followUpTimer: Timer?
    private var lastSedentaryCheckTime: Date?
    
    // 压力检测相关
    private var stressReminderSent = false
    private var stressReminderTime: Date?
    private var baselineHRV: Double = 0
    private var lastStressCheckTime: Date?
    
    // 运动检测相关
    private var exerciseReminderSent = false
    private var exerciseReminderTime: Date?
    private var lastExerciseCheckTime: Date?
    
    // 睡眠检测相关
    private var sleepReminderSent = false
    private var lastSleepCheckTime: Date?
    
    // 晒太阳检测相关
    private var sunExposureReminderSent = false
    private var lastSunExposureCheckTime: Date?
    
    private init() {
        setupMonitoring()
        checkAndResetDailyCounts()
    }
    
    // MARK: - 设置监测
    private func setupMonitoring() {
        // 启动步数监测
        motionManager.startStepCounting { [weak self] steps in
            self?.handleStepCountUpdate(steps)
        }
        
        // 启动心率监测
        healthKitManager.startHeartRateMonitoring { [weak self] heartRate in
            self?.handleHeartRateUpdate(heartRate)
        }
        
        // 启动HRV监测
        healthKitManager.startHRVMonitoring { [weak self] hrv in
            self?.handleHRVUpdate(hrv)
        }
        
        // 启动环境监测
        EnvironmentSensorManager.shared.startLocationMonitoring()
    }
    
    // MARK: - 开始监测
    func startMonitoring() {
        print("开始健康监测")
        setupMonitoring()
    }
    
    // MARK: - 停止监测
    func stopMonitoring() {
        motionManager.stopStepCounting()
        healthKitManager.stopHeartRateMonitoring()
        healthKitManager.stopHRVMonitoring()
        followUpTimer?.invalidate()
        followUpTimer = nil
    }
    
    // MARK: - 检查并重置每日计数
    private func checkAndResetDailyCounts() {
        let calendar = Calendar.current
        let today = calendar.startOfDay(for: Date())
        
        if lastResetDate == nil || !calendar.isDate(lastResetDate!, inSameDayAs: today) {
            // 重置每日计数
            dailyReminderCounts = [:]
            lastResetDate = today
            
            // 重置所有提醒状态
            resetAllMonitoringStates()
            
            print("每日提醒计数已重置")
        }
    }
    
    // MARK: - 重置所有监测状态
    private func resetAllMonitoringStates() {
        sedentaryReminderSent = false
        sedentaryReminderTime = nil
        stepsBeforeReminder = 0
        isMonitoringFollowUp = false
        followUpTimer?.invalidate()
        followUpTimer = nil
        lastSedentaryCheckTime = nil
        
        stressReminderSent = false
        stressReminderTime = nil
        lastStressCheckTime = nil
        
        exerciseReminderSent = false
        exerciseReminderTime = nil
        lastExerciseCheckTime = nil
        
        sleepReminderSent = false
        lastSleepCheckTime = nil
        
        sunExposureReminderSent = false
        lastSunExposureCheckTime = nil
    }
    
    // MARK: - 检查每日提醒限制
    private func canSendReminder(for taskType: TaskType) -> Bool {
        checkAndResetDailyCounts()
        
        let currentCount = dailyReminderCounts[taskType] ?? 0
        let maxDailyReminders = getMaxDailyReminders(for: taskType)
        
        return currentCount < maxDailyReminders
    }
    
    // MARK: - 获取每日最大提醒次数
    private func getMaxDailyReminders(for taskType: TaskType) -> Int {
        switch taskType {
        case .sedentary:
            return 2 // 久坐提醒每天最多2次
        case .stress:
            return 2 // 压力提醒每天最多2次
        case .exercise:
            return 1 // 运动提醒每天最多1次
        case .sleep:
            return 1 // 睡眠提醒每天最多1次
        case .sunExposure:
            return 2 // 晒太阳提醒每天最多2次
        }
    }
    
    // MARK: - 记录提醒发送
    private func recordReminderSent(for taskType: TaskType) {
        let currentCount = dailyReminderCounts[taskType] ?? 0
        dailyReminderCounts[taskType] = currentCount + 1
        print("\(taskType.title) 提醒已发送，今日第 \(currentCount + 1) 次")
    }
    
    // MARK: - 处理步数更新
    private func handleStepCountUpdate(_ steps: Int) {
        // 检查是否需要重置每日计数
        checkAndResetDailyCounts()
        
        // 防止频繁检查（至少间隔5分钟）
        let now = Date()
        if let lastCheck = lastSedentaryCheckTime,
           now.timeIntervalSince(lastCheck) < 300 { // 5分钟
            print("久坐检测：距离上次检查不足5分钟，跳过")
            return
        }
        lastSedentaryCheckTime = now
        
        print("久坐检测：开始检查步数状态，当前总步数 \(steps)")
        
        // 久坐检测：1小时内步数<40步
        let calendar = Calendar.current
        let oneHourAgo = calendar.date(byAdding: .hour, value: -1, to: now) ?? now
        
        // 获取过去一小时的步数
        healthKitManager.getSteps(from: oneHourAgo, to: now) { [weak self] hourlySteps in
            DispatchQueue.main.async {
                print("久坐检测：过去1小时步数 \(hourlySteps) 步")
                self?.checkSedentaryCondition(hourlySteps)
            }
        }
        
        // 久坐后续检测
        if sedentaryReminderSent {
            checkSedentaryFollowUp(steps)
        }
    }
    
    // MARK: - 检查久坐条件
    private func checkSedentaryCondition(_ hourlySteps: Int) {
        // 检查是否已经发送过提醒
        if sedentaryReminderSent {
            return
        }
        
        // 检查每日限制
        if !canSendReminder(for: .sedentary) {
            print("久坐提醒已达到每日限制")
            return
        }
        
        // 检查步数条件：1小时内步数<40步
        if hourlySteps < 40 {
            print("检测到久坐：过去1小时步数 \(hourlySteps) 步")
            
            sedentaryReminderSent = true
            sedentaryReminderTime = Date()
            stepsBeforeReminder = hourlySteps
            
            // 记录提醒发送
            recordReminderSent(for: .sedentary)
            
            // 发送久坐建议通知
            let userElement = profileManager.userProfile.fiveElements?.primary ?? "金"
            systemNotificationManager.sendSuggestionNotification(
                for: userElement,
                taskType: .sedentary
            )
            
            // 开始后续检测
            startSedentaryFollowUpMonitoring()
        } else {
            print("久坐检测：过去1小时步数 \(hourlySteps) 步，未达到久坐条件")
        }
    }
    
    // MARK: - 开始久坐后续监测
    private func startSedentaryFollowUpMonitoring() {
        isMonitoringFollowUp = true
        
        // 10分钟后检查步数变化
        followUpTimer = Timer.scheduledTimer(withTimeInterval: 600, repeats: false) { [weak self] _ in
            self?.checkSedentaryFollowUp(0)
        }
    }
    
    // MARK: - 检查久坐后续
    private func checkSedentaryFollowUp(_ currentSteps: Int) {
        guard sedentaryReminderSent else { return }
        
        let calendar = Calendar.current
        let reminderTime = sedentaryReminderTime ?? Date()
        let tenMinutesAfterReminder = calendar.date(byAdding: .minute, value: 10, to: reminderTime) ?? Date()
        
        // 获取提醒后10分钟内的步数
        healthKitManager.getSteps(from: reminderTime, to: tenMinutesAfterReminder) { [weak self] stepsAfterReminder in
            DispatchQueue.main.async {
                self?.evaluateSedentaryFollowUp(stepsAfterReminder)
            }
        }
    }
    
    // MARK: - 评估久坐后续
    private func evaluateSedentaryFollowUp(_ stepsAfterReminder: Int) {
        let stepsIncrease = stepsAfterReminder - stepsBeforeReminder
        
        if stepsIncrease >= 100 {
            // 成功活动，发送完成通知
            let userElement = profileManager.userProfile.fiveElements?.primary ?? "金"
            systemNotificationManager.sendCompletionNotification(
                for: userElement,
                taskType: .sedentary
            )
            
            print("久坐后续检测成功：步数增加 \(stepsIncrease) 步")
        } else {
            print("久坐后续检测：步数增加不足，仅增加 \(stepsIncrease) 步")
        }
        
        // 重置监测状态
        resetSedentaryMonitoring()
    }
    
    // MARK: - 重置久坐监测
    private func resetSedentaryMonitoring() {
        sedentaryReminderSent = false
        sedentaryReminderTime = nil
        stepsBeforeReminder = 0
        isMonitoringFollowUp = false
        followUpTimer?.invalidate()
        followUpTimer = nil
    }
    
    // MARK: - 处理心率更新
    private func handleHeartRateUpdate(_ heartRate: Double) {
        // 防止频繁检查（至少间隔10分钟）
        let now = Date()
        if let lastCheck = lastExerciseCheckTime,
           now.timeIntervalSince(lastCheck) < 600 { // 10分钟
            return
        }
        lastExerciseCheckTime = now
        
        // 运动检测：心率持续>120超过10分钟
        // 这里需要实现心率持续监测逻辑
        if heartRate > 120 && !exerciseReminderSent {
            checkExerciseCondition(heartRate)
        }
    }
    
    // MARK: - 检查运动条件
    private func checkExerciseCondition(_ heartRate: Double) {
        // 检查是否已经发送过提醒
        if exerciseReminderSent {
            return
        }
        
        // 检查每日限制
        if !canSendReminder(for: .exercise) {
            print("运动提醒已达到每日限制")
            return
        }
        
        exerciseReminderSent = true
        exerciseReminderTime = Date()
        
        // 记录提醒发送
        recordReminderSent(for: .exercise)
        
        // 发送运动建议通知
        let userElement = profileManager.userProfile.fiveElements?.primary ?? "金"
        systemNotificationManager.sendSuggestionNotification(
            for: userElement,
            taskType: .exercise
        )
        
        print("检测到运动：心率 \(heartRate) BPM")
    }
    
    // MARK: - 处理HRV更新
    private func handleHRVUpdate(_ hrv: Double) {
        // 防止频繁检查（至少间隔15分钟）
        let now = Date()
        if let lastCheck = lastStressCheckTime,
           now.timeIntervalSince(lastCheck) < 900 { // 15分钟
            return
        }
        lastStressCheckTime = now
        
        // 压力检测：HRV持续低于个人基线20%
        if baselineHRV == 0 {
            baselineHRV = hrv
            return
        }
        
        let hrvThreshold = baselineHRV * 0.8
        
        if hrv < hrvThreshold && !stressReminderSent {
            checkStressCondition(hrv, threshold: hrvThreshold)
        }
    }
    
    // MARK: - 检查压力条件
    private func checkStressCondition(_ hrv: Double, threshold: Double) {
        // 检查是否已经发送过提醒
        if stressReminderSent {
            return
        }
        
        // 检查每日限制
        if !canSendReminder(for: .stress) {
            print("压力提醒已达到每日限制")
            return
        }
        
        stressReminderSent = true
        stressReminderTime = Date()
        
        // 记录提醒发送
        recordReminderSent(for: .stress)
        
        // 发送压力建议通知
        let userElement = profileManager.userProfile.fiveElements?.primary ?? "金"
        systemNotificationManager.sendSuggestionNotification(
            for: userElement,
            taskType: .stress
        )
        
        // 开始压力后续检测
        startStressFollowUpMonitoring()
        
        print("检测到压力：HRV \(hrv)ms，低于阈值 \(threshold)ms")
    }
    
    // MARK: - 开始压力后续监测
    private func startStressFollowUpMonitoring() {
        // 30分钟后检查HRV是否改善
        Timer.scheduledTimer(withTimeInterval: 1800, repeats: false) { [weak self] _ in
            self?.checkStressFollowUp()
        }
    }
    
    // MARK: - 检查压力后续
    private func checkStressFollowUp() {
        guard stressReminderSent else { return }
        
        // 获取当前HRV
        healthKitManager.getCurrentHRV { [weak self] currentHRV in
            DispatchQueue.main.async {
                self?.evaluateStressFollowUp(currentHRV)
            }
        }
    }
    
    // MARK: - 评估压力后续
    private func evaluateStressFollowUp(_ currentHRV: Double) {
        let hrvThreshold = baselineHRV * 0.8
        
        if currentHRV >= hrvThreshold {
            // HRV改善，发送完成通知
            let userElement = profileManager.userProfile.fiveElements?.primary ?? "金"
            systemNotificationManager.sendCompletionNotification(
                for: userElement,
                taskType: .stress
            )
            
            print("压力后续检测成功：HRV恢复到 \(currentHRV)ms")
        } else {
            print("压力后续检测：HRV仍未改善，当前值 \(currentHRV)ms")
        }
        
        // 重置监测状态
        resetStressMonitoring()
    }
    
    // MARK: - 重置压力监测
    private func resetStressMonitoring() {
        stressReminderSent = false
        stressReminderTime = nil
    }
    
    // MARK: - 获取当前监测状态
    func getCurrentMonitoringStatus() -> [String: Any] {
        return [
            "dailyCounts": dailyReminderCounts,
            "sedentaryReminderSent": sedentaryReminderSent,
            "stressReminderSent": stressReminderSent,
            "exerciseReminderSent": exerciseReminderSent,
            "isMonitoringFollowUp": isMonitoringFollowUp,
            "lastResetDate": lastResetDate ?? Date()
        ]
    }
}

// MARK: - 健康状态枚举
enum HealthStatus {
    case normal
    case warning
    case critical
} 
----

----
FilePath: ming-ling-watch-os Watch App/Services/NotificationController.swift
Lines: 228
import SwiftUI
import UserNotifications
import WatchKit

// MARK: - 自定义通知控制器
final class NotificationController: WKUserNotificationHostingController<PetNotificationLongLookView> {
    
    // 启用交互式通知
    override class var isInteractive: Bool {
        return true
    }
    
    // 通知内容
    var content: UNNotificationContent!
    var date: Date!
    var userElement: String = "金"
    var notificationUserInfo: [String: Any] = [:]
    
    override func didReceive(_ notification: UNNotification) {
        content = notification.request.content
        date = notification.date
        
        // 解析通知数据
        let userInfo = notification.request.content.userInfo
        print("=== 通知接收调试 ===")
        print("原始 userInfo: \(userInfo)")
        
        if let element = userInfo["element"] as? String {
            self.userElement = element
            print("设置用户元素: \(element)")
        } else {
            print("⚠️ 未找到元素信息，使用默认值: \(self.userElement)")
        }
        
        self.notificationUserInfo = userInfo as? [String: Any] ?? [:]
        print("==================")
    }
    
    override var body: PetNotificationLongLookView {
        return PetNotificationLongLookView(
            content: content,
            date: date,
            userElement: userElement,
            notificationUserInfo: notificationUserInfo
        )
    }
}

// MARK: - 自定义通知视图
struct PetNotificationLongLookView: View {
    @State private var showMore = false
    @StateObject private var profileManager = UserProfileManager.shared
    
    let content: UNNotificationContent?
    let date: Date?
    let userElement: String
    let notificationUserInfo: [String: Any]
    
    var body: some View {
        // 主容器 - 只包含背景和对话框
        ZStack {
            // 背景色
            PetUtils.getElementBackgroundColor(for: userElement)
                .ignoresSafeArea()
            
            // 对话框
            VStack(alignment: .leading, spacing: 6) {
                Text(getNotificationMessage())
                    .font(.system(size: 14, weight: .medium))
                    .foregroundColor(PetUtils.getElementTextColor(for: userElement))
                    .multilineTextAlignment(.leading)
                    .lineLimit(3)
                    .fixedSize(horizontal: false, vertical: true)
            }
            .padding(.horizontal, 16)
            .padding(.vertical, 12)
            .frame(width: 112, height: 80, alignment: .leading)
            .background(
                RoundedRectangle(cornerRadius: 16)
                    .fill(PetUtils.getElementDialogColor(for: userElement).opacity(0.95))
                    .overlay(
                        RoundedRectangle(cornerRadius: 16)
                            .stroke(PetUtils.getElementDialogColor(for: userElement), lineWidth: 1.5)
                    )
            )
            .shadow(color: .black.opacity(0.15), radius: 6, x: 0, y: 3)
            .position(x: 70, y: 50)
        }
        .frame(width: 200, height: 240)
        // 使用overlay添加其他元素，实现真正的绝对定位
        .overlay(
            // 亲密度显示
            Group {
                if isCompletionNotification() {
                    HStack(spacing: 4) {
                        Image(systemName: getIntimacyIcon())
                            .font(.caption2)
                            .foregroundColor(Color(hex: profileManager.userProfile.intimacyGradeColor))
                        
                        Text("+\(getIntimacyPoints())")
                            .font(.system(size: 10, weight: .bold, design: .rounded))
                            .foregroundColor(PetUtils.getElementTextColor(for: userElement))
                    }
                    .padding(.horizontal, 16)
                    .padding(.vertical, 3)
                    .position(x: 110, y: 75)
                }
            }
        )
        .overlay(
            // GIF动画层
            Group {
                if let useGIFAnimation = notificationUserInfo["useGIFAnimation"] as? Bool, useGIFAnimation {
                    GIFAnimationView(gifName: getGIFName(), isPlaying: true)
                        .frame(width: 240, height: 240)
                        .clipped()
                } else {
                    Image(PetUtils.getPetSpeakImageName(for: userElement))
                        .resizable()
                        .aspectRatio(contentMode: .fit)
                        .frame(width: 160, height: 160)
                }
            }
            .position(x: 140, y: 160)
        )
        .onAppear {
            loadNotificationContent()
        }
    }
    
    // MARK: - 判断是否为完成通知
    private func isCompletionNotification() -> Bool {
        return notificationUserInfo["type"] as? String == "completion"
    }
    
    // MARK: - 获取亲密度图标
    private func getIntimacyIcon() -> String {
        let intimacyGrade = profileManager.userProfile.intimacyGrade
        switch intimacyGrade {
        case 1:
            return "heart"
        case 2:
            return "heart.fill"
        case 3:
            return "heart.circle.fill"
        default:
            return "heart"
        }
    }
    
    // MARK: - 获取亲密度奖励点数
    private func getIntimacyPoints() -> Int {
        if let taskTypeString = notificationUserInfo["taskType"] as? String,
           let taskType = TaskType(rawValue: taskTypeString),
           let completion = ReminderContentManager.shared.getCompletionContent(for: taskType, element: userElement) {
            return completion.intimacyPoints
        }
        return 20 // 默认奖励
    }
    
    // MARK: - 获取GIF名称
    private func getGIFName() -> String {
        let intimacyGrade = profileManager.userProfile.intimacyGrade
        return PetUtils.getPetGIFName(for: userElement, intimacyGrade: intimacyGrade)
    }
    
    // MARK: - 获取通知消息
    private func getNotificationMessage() -> String {
        if let typeString = notificationUserInfo["type"] as? String {
            switch typeString {
            case "suggestion":
                // 建议通知
                if let taskTypeString = notificationUserInfo["taskType"] as? String,
                   let taskType = TaskType(rawValue: taskTypeString),
                   let suggestion = ReminderContentManager.shared.getSuggestionContent(for: taskType, element: userElement) {
                    return suggestion.message
                } else {
                    // 如果没有找到具体的任务类型，尝试获取随机建议
                    if let suggestion = ReminderContentManager.shared.getRandomSuggestionContent(for: userElement) {
                        return suggestion.1.message
                    }
                }
            case "completion":
                // 完成通知
                if let taskTypeString = notificationUserInfo["taskType"] as? String,
                   let taskType = TaskType(rawValue: taskTypeString),
                   let completion = ReminderContentManager.shared.getCompletionContent(for: taskType, element: userElement) {
                    return completion.message
                } else {
                    // 如果没有找到具体的任务类型，尝试获取随机完成
                    if let completion = ReminderContentManager.shared.getRandomCompletionContent(for: userElement) {
                        return completion.1.message
                    }
                }
            case "gif":
                // GIF通知
                if let message = content?.body {
                    return message
                }
            default:
                break
            }
        }
        
        // 默认消息
        return "今天也要加油哦！"
    }
    
    // MARK: - 加载通知内容
    private func loadNotificationContent() {
        // 这里可以添加额外的内容加载逻辑
        print("=== 通知调试信息 ===")
        print("用户元素: \(userElement)")
        print("通知用户信息: \(notificationUserInfo)")
        print("背景颜色: \(PetUtils.getElementBackgroundColor(for: userElement))")
        print("对话框颜色: \(PetUtils.getElementDialogColor(for: userElement))")
        print("文字颜色: \(PetUtils.getElementTextColor(for: userElement))")
        
        // 检查是否使用GIF动画
        if let useGIFAnimation = notificationUserInfo["useGIFAnimation"] as? Bool, useGIFAnimation {
            let gifName = getGIFName()
            print("GIF动画名称: \(gifName)")
        } else {
            print("图片名称: \(PetUtils.getPetSpeakImageName(for: userElement))")
        }
        print("==================")
    }
} 
----

----
FilePath: ming-ling-watch-os Watch App/Services/SystemNotificationManager.swift
Lines: 301
import Foundation
import UserNotifications
import WatchKit

// MARK: - 系统通知管理器
class SystemNotificationManager: NSObject, ObservableObject {
    static let shared = SystemNotificationManager()
    
    override init() {
        super.init()
        requestNotificationPermission()
        setupNotificationCategories()
    }
    
    // MARK: - 请求通知权限
    func requestNotificationPermission() {
        UNUserNotificationCenter.current().requestAuthorization(options: [.alert, .sound, .badge]) { granted, error in
            if granted {
                print("通知权限已获取")
            } else if let error = error {
                print("通知权限请求失败: \(error.localizedDescription)")
            }
        }
    }
    
    // MARK: - 设置通知类别
    func setupNotificationCategories() {
        // 创建宠物通知类别，支持自定义 Long Look 界面
        let petCategory = UNNotificationCategory(
            identifier: "PET_NOTIFICATION",
            actions: [],
            intentIdentifiers: [],
            options: [.customDismissAction]
        )
        
        // 注册通知类别
        UNUserNotificationCenter.current().setNotificationCategories([petCategory])
    }
    
    // MARK: - 发送建议通知
    func sendSuggestionNotification(for element: String, taskType: TaskType, delay: TimeInterval = 1) {
        guard let content = NotificationUtils.getSuggestionContent(for: element, taskType: taskType) else {
            print("无法获取建议内容")
            return
        }
        
        let notification = UNMutableNotificationContent()
        notification.title = content.title
        notification.body = content.message
        notification.sound = .default
        
        // 添加自定义数据
        notification.userInfo = [
            "element": element,
            "taskType": taskType.rawValue,
            "type": "suggestion",
            "useGIFAnimation": false
        ]
        
        // 设置通知类别以启用自定义 Long Look 界面
        notification.categoryIdentifier = "PET_NOTIFICATION"
        
        // 创建触发器
        let trigger = UNTimeIntervalNotificationTrigger(timeInterval: delay, repeats: false)
        
        // 创建请求
        let request = UNNotificationRequest(
            identifier: "suggestion-\(taskType.rawValue)-\(UUID().uuidString)",
            content: notification,
            trigger: trigger
        )
        
        // 发送通知
        UNUserNotificationCenter.current().add(request) { error in
            if let error = error {
                print("发送建议通知失败: \(error.localizedDescription)")
            } else {
                print("建议通知已发送")
            }
        }
    }
    
    // MARK: - 发送完成通知
    func sendCompletionNotification(for element: String, taskType: TaskType, delay: TimeInterval = 1) {
        guard let content = NotificationUtils.getCompletionContent(for: element, taskType: taskType) else {
            print("无法获取完成内容")
            return
        }
        
        let notification = UNMutableNotificationContent()
        notification.title = content.title
        notification.body = content.message
        notification.sound = .default
        
        // 添加自定义数据
        notification.userInfo = [
            "element": element,
            "taskType": taskType.rawValue,
            "type": "completion",
            "useGIFAnimation": true
        ]
        
        // 设置通知类别以启用自定义 Long Look 界面
        notification.categoryIdentifier = "PET_NOTIFICATION"
        
        // 创建触发器
        let trigger = UNTimeIntervalNotificationTrigger(timeInterval: delay, repeats: false)
        
        // 创建请求
        let request = UNNotificationRequest(
            identifier: "completion-\(taskType.rawValue)-\(UUID().uuidString)",
            content: notification,
            trigger: trigger
        )
        
        // 发送通知
        UNUserNotificationCenter.current().add(request) { error in
            if let error = error {
                print("发送完成通知失败: \(error.localizedDescription)")
            } else {
                print("完成通知已发送")
            }
        }
    }
    
    // MARK: - 发送随机建议通知
    func sendRandomSuggestionNotification(for element: String, delay: TimeInterval = 1) {
        guard let (taskType, suggestion) = ReminderContentManager.shared.getRandomSuggestionContent(for: element) else {
            print("无法获取随机建议内容")
            return
        }
        
        let notification = UNMutableNotificationContent()
        notification.title = taskType.title
        notification.body = suggestion.message
        notification.sound = .default
        
        // 添加自定义数据
        notification.userInfo = [
            "element": element,
            "taskType": taskType.rawValue,
            "type": "suggestion",
            "useGIFAnimation": false
        ]
        
        // 设置通知类别以启用自定义 Long Look 界面
        notification.categoryIdentifier = "PET_NOTIFICATION"
        
        // 创建触发器
        let trigger = UNTimeIntervalNotificationTrigger(timeInterval: delay, repeats: false)
        
        // 创建请求
        let request = UNNotificationRequest(
            identifier: "random-suggestion-\(UUID().uuidString)",
            content: notification,
            trigger: trigger
        )
        
        // 发送通知
        UNUserNotificationCenter.current().add(request) { error in
            if let error = error {
                print("发送随机建议通知失败: \(error.localizedDescription)")
            } else {
                print("随机建议通知已发送")
            }
        }
    }
    
    // MARK: - 发送随机完成通知
    func sendRandomCompletionNotification(for element: String, delay: TimeInterval = 1) {
        guard let (taskType, completion) = ReminderContentManager.shared.getRandomCompletionContent(for: element) else {
            print("无法获取随机完成内容")
            return
        }
        
        let notification = UNMutableNotificationContent()
        notification.title = taskType.title
        notification.body = completion.message
        notification.sound = .default
        
        // 添加自定义数据
        notification.userInfo = [
            "element": element,
            "taskType": taskType.rawValue,
            "type": "completion",
            "useGIFAnimation": true
        ]
        
        // 设置通知类别以启用自定义 Long Look 界面
        notification.categoryIdentifier = "PET_NOTIFICATION"
        
        // 创建触发器
        let trigger = UNTimeIntervalNotificationTrigger(timeInterval: delay, repeats: false)
        
        // 创建请求
        let request = UNNotificationRequest(
            identifier: "random-completion-\(UUID().uuidString)",
            content: notification,
            trigger: trigger
        )
        
        // 发送通知
        UNUserNotificationCenter.current().add(request) { error in
            if let error = error {
                print("发送随机完成通知失败: \(error.localizedDescription)")
            } else {
                print("随机完成通知已发送")
            }
        }
    }
    
    // MARK: - 发送GIF通知（兼容旧接口）
    func sendGIFNotification(for element: String, intimacyGrade: Int, emotion: String, message: String, delay: TimeInterval = 1) {
        let notification = UNMutableNotificationContent()
        notification.title = "宠物消息"
        notification.body = message
        notification.sound = .default
        
        // 添加自定义数据
        notification.userInfo = [
            "element": element,
            "intimacyGrade": intimacyGrade,
            "emotion": emotion,
            "type": "gif",
            "useGIFAnimation": true
        ]
        
        // 设置通知类别以启用自定义 Long Look 界面
        notification.categoryIdentifier = "PET_NOTIFICATION"
        
        // 创建触发器
        let trigger = UNTimeIntervalNotificationTrigger(timeInterval: delay, repeats: false)
        
        // 创建请求
        let request = UNNotificationRequest(
            identifier: "gif-notification-\(UUID().uuidString)",
            content: notification,
            trigger: trigger
        )
        
        // 发送通知
        UNUserNotificationCenter.current().add(request) { error in
            if let error = error {
                print("发送GIF通知失败: \(error.localizedDescription)")
            } else {
                print("GIF通知已发送")
            }
        }
    }
    
    // MARK: - 发送延时GIF通知（兼容旧接口）
    func sendGIFNotificationWithDelay(for element: String, intimacyGrade: Int, emotion: String, message: String, delay: TimeInterval) {
        sendGIFNotification(for: element, intimacyGrade: intimacyGrade, emotion: emotion, message: message, delay: delay)
    }
    
    // MARK: - 取消所有通知
    func cancelAllNotifications() {
        UNUserNotificationCenter.current().removeAllPendingNotificationRequests()
        print("所有通知已取消")
    }
    
    // MARK: - 获取待处理通知数量
    func getPendingNotificationCount(completion: @escaping (Int) -> Void) {
        UNUserNotificationCenter.current().getPendingNotificationRequests { requests in
            DispatchQueue.main.async {
                completion(requests.count)
            }
        }
    }
}

// MARK: - UNUserNotificationCenterDelegate
extension SystemNotificationManager: UNUserNotificationCenterDelegate {
    func userNotificationCenter(_ center: UNUserNotificationCenter, willPresent notification: UNNotification, withCompletionHandler completionHandler: @escaping (UNNotificationPresentationOptions) -> Void) {
        // 即使应用在前台也显示通知
        completionHandler([.banner, .sound])
    }
    
    func userNotificationCenter(_ center: UNUserNotificationCenter, didReceive response: UNNotificationResponse, withCompletionHandler completionHandler: @escaping () -> Void) {
        // 处理通知点击事件
        let userInfo = response.notification.request.content.userInfo
        
        if let element = userInfo["element"] as? String,
           let typeString = userInfo["type"] as? String {
            print("用户点击了通知 - 元素: \(element), 类型: \(typeString)")
            
            // 如果是完成通知，增加亲密度
            if typeString == "completion" {
                if let taskTypeString = userInfo["taskType"] as? String,
                   let taskType = TaskType(rawValue: taskTypeString),
                   let completion = ReminderContentManager.shared.getCompletionContent(for: taskType, element: element) {
                    // 增加亲密度
                    UserProfileManager.shared.addIntimacy(completion.intimacyPoints)
                    print("完成通知：增加亲密度 \(completion.intimacyPoints) 点")
                }
            }
        }
        
        completionHandler()
    }
} 
----

----
FilePath: ming-ling-watch-os Watch App/Services/UserProfileManager.swift
Lines: 152
import Foundation
import SwiftUI

// MARK: - 用户档案管理器
class UserProfileManager: ObservableObject {
    static let shared = UserProfileManager()
    
    @Published var userProfile: UserProfile = UserProfile()
    @Published var isProfileComplete: Bool = false
    
    private let userDefaults = UserDefaults.standard
    private let profileKey = "userProfile"
    private let intimacyChangeManager = IntimacyChangeManager.shared
    
    private init() {
        loadProfile()
    }
    
    // MARK: - 加载用户档案
    private func loadProfile() {
        if let data = userDefaults.data(forKey: profileKey),
           let profile = try? JSONDecoder().decode(UserProfile.self, from: data) {
            userProfile = profile
            isProfileComplete = profile.birthday != nil && profile.fiveElements != nil
        }
    }
    
    // MARK: - 保存用户档案
    private func saveProfile() {
        if let data = try? JSONEncoder().encode(userProfile) {
            userDefaults.set(data, forKey: profileKey)
        }
    }
    
    // MARK: - 设置生日和五行属性
    func setProfile(birthday: Date, sex: Int, fiveElements: FiveElements, baziData: BaziData) {
        userProfile.birthday = birthday
        userProfile.sex = sex
        userProfile.fiveElements = fiveElements
        userProfile.baziData = baziData
        userProfile.petRecommendation = getPetName(for: fiveElements.primary)
        userProfile.updateHealthStreak()
        
        isProfileComplete = true
        saveProfile()
    }
    
    // MARK: - 更新健康天数
    func updateHealthStreak() {
        userProfile.updateHealthStreak()
        saveProfile()
    }
    
    // MARK: - 重置档案
    func resetProfile() {
        userProfile = UserProfile()
        isProfileComplete = false
        userDefaults.removeObject(forKey: profileKey)
    }
    
    // MARK: - 亲密值管理
    func addIntimacy(_ points: Int) {
        userProfile.addIntimacy(points)
        saveProfile()
        
        // 显示亲密值增加通知
        intimacyChangeManager.showChange(points: points, isPositive: true)
    }
    
    func reduceIntimacy(_ points: Int) {
        userProfile.reduceIntimacy(points)
        saveProfile()
        
        // 显示亲密值减少通知
        intimacyChangeManager.showChange(points: points, isPositive: false)
    }
    
    // MARK: - 获取主题颜色
    func getThemeColor() -> Color {
        guard let element = userProfile.fiveElements?.primary else {
            return Color.blue
        }
        
        switch element {
        case "金":
            return Color(hex: "FFD700")
        case "木":
            return Color(hex: "228B22")
        case "水":
            return Color(hex: "4169E1")
        case "火":
            return Color(hex: "DC143C")
        case "土":
            return Color(hex: "8B4513")
        default:
            return Color.blue
        }
    }
    
    // MARK: - 获取宠物名称
    private func getPetName(for element: String) -> String {
        switch element {
        case "金":
            return "金金"
        case "木":
            return "木木"
        case "水":
            return "水水"
        case "火":
            return "火火"
        case "土":
            return "土土"
        default:
            return "土土"
        }
    }
    
    // MARK: - 获取问候语
    func getGreeting() -> String {
        guard let petName = userProfile.petRecommendation else {
            return "你好，我是您的健康助手！"
        }
        
        let streak = userProfile.healthStreak
        return "你好，我是\(petName)！今天是您坚持健康的第\(streak)天。"
    }
    
    // MARK: - 获取压力状态描述
    func getStressStatusDescription() -> String {
        guard let element = userProfile.fiveElements?.primary else {
            return "您目前的压力状态："
        }
        
        switch element {
        case "金":
            return "您的肺气状态："
        case "木":
            return "您的肝气状态："
        case "水":
            return "您的肾气状态："
        case "火":
            return "您的心气状态："
        case "土":
            return "您的脾气状态："
        default:
            return "您目前的压力状态："
        }
    }
}

 
 
----

----
FilePath: ming-ling-watch-os Watch App/Services/WatchOSAppDelegate.swift
Lines: 44
import UserNotifications
import WatchKit
import os

// MARK: - WatchOS 应用代理
class WatchOSAppDelegate: NSObject, WKApplicationDelegate, UNUserNotificationCenterDelegate {
    
    func applicationDidFinishLaunching() {
        // 请求通知权限
        UNUserNotificationCenter.current().requestAuthorization(options: [.alert, .sound, .badge]) { (allowed, error) in
            if allowed {
                os_log(.debug, "通知权限已获取")
            } else {
                os_log(.debug, "通知权限未获取")
            }
        }
        
        // 设置通知代理
        let center = UNUserNotificationCenter.current()
        center.delegate = self
    }
    
    // MARK: - 处理远程通知
    func didReceiveRemoteNotification(_ userInfo: [AnyHashable : Any]) async -> WKBackgroundFetchResult {
        return .noData
    }
    
    // MARK: - 前台显示通知
    func userNotificationCenter(_ center: UNUserNotificationCenter, willPresent notification: UNNotification) async -> UNNotificationPresentationOptions {
        return [.badge, .banner, .list]
    }
    
    // MARK: - 处理通知点击
    func userNotificationCenter(_ center: UNUserNotificationCenter, didReceive response: UNNotificationResponse, withCompletionHandler completionHandler: @escaping () -> Void) {
        let userInfo = response.notification.request.content.userInfo
        
        if let element = userInfo["element"] as? String,
           let typeString = userInfo["type"] as? String {
            print("用户点击了通知 - 元素: \(element), 类型: \(typeString)")
        }
        
        completionHandler()
    }
} 
----

----
FilePath: ming-ling-watch-os Watch App/Utils/GIFAnimationManager.swift
Lines: 205
import Foundation
import SwiftUI
import ImageIO

// MARK: - GIF动画管理器
class GIFAnimationManager: ObservableObject {
    static let shared = GIFAnimationManager()
    
    @Published var isPlaying: Bool = false
    @Published var currentImage: UIImage?
    @Published var currentGIFIndex: Int = 0
    
    private var gifImages: [UIImage] = []
    private var gifDurations: [TimeInterval] = []
    private var animationTimer: Timer?
    private var currentFrameIndex: Int = 0
    private var totalFrames: Int = 0
    
    private init() {}
    
    // MARK: - 加载GIF动画
    func loadGIF(named gifName: String) {
        // 首先尝试从Bundle中加载
        if let url = Bundle.main.url(forResource: gifName, withExtension: "gif") {
            print("✅ 从Bundle加载GIF文件: \(gifName)")
            loadGIFFromURL(url)
            return
        }
        
        // 如果Bundle中没有，尝试从项目根目录的assets文件夹加载
        let projectRoot = FileManager.default.currentDirectoryPath
        let assetsPath = "\(projectRoot)/assets/\(gifName).gif"
        let assetsURL = URL(fileURLWithPath: assetsPath)
        
        if FileManager.default.fileExists(atPath: assetsPath) {
            print("✅ 从assets目录加载GIF文件: \(assetsPath)")
            loadGIFFromURL(assetsURL)
            return
        }
        
        // 如果都找不到，尝试从应用Bundle的assets目录加载
        if let bundleURL = Bundle.main.url(forResource: "assets/\(gifName)", withExtension: "gif") {
            print("✅ 从Bundle的assets目录加载GIF文件: \(gifName)")
            loadGIFFromURL(bundleURL)
            return
        }
        
        // 尝试从Bundle中加载不带路径的文件名
        let fileName = gifName.components(separatedBy: "/").last ?? gifName
        if let bundleURL = Bundle.main.url(forResource: fileName, withExtension: "gif") {
            print("✅ 从Bundle加载文件名: \(fileName)")
            loadGIFFromURL(bundleURL)
            return
        }
        
        print("❌ 无法找到GIF文件: \(gifName)")
        print("尝试过的路径:")
        print("  - Bundle: \(gifName).gif")
        print("  - Assets: \(assetsPath)")
        print("  - Bundle Assets: assets/\(gifName).gif")
        print("  - Bundle FileName: \(fileName).gif")
        
        // 清空当前状态
        gifImages.removeAll()
        gifDurations.removeAll()
        totalFrames = 0
        currentImage = nil
    }
    
    // MARK: - 从URL加载GIF
    private func loadGIFFromURL(_ url: URL) {
        guard let data = try? Data(contentsOf: url),
              let source = CGImageSourceCreateWithData(data as CFData, nil) else {
            print("无法解析GIF文件")
//            createDefaultAnimation()
            return
        }
        
        let frameCount = CGImageSourceGetCount(source)
        gifImages.removeAll()
        gifDurations.removeAll()
        
        for i in 0..<frameCount {
            if let cgImage = CGImageSourceCreateImageAtIndex(source, i, nil) {
                let image = UIImage(cgImage: cgImage)
                gifImages.append(image)
                
                // 获取帧持续时间
                if let properties = CGImageSourceCopyPropertiesAtIndex(source, i, nil) as? [String: Any],
                   let gifInfo = properties[kCGImagePropertyGIFDictionary as String] as? [String: Any] {
                    
                    var duration: TimeInterval = 0.1 // 默认100ms
                    
                    if let delayTime = gifInfo[kCGImagePropertyGIFDelayTime as String] as? Double {
                        duration = delayTime
                    } else if let unclampedDelayTime = gifInfo[kCGImagePropertyGIFUnclampedDelayTime as String] as? Double {
                        duration = unclampedDelayTime
                    }
                    
                    // 确保最小持续时间
                    if duration < 0.02 {
                        duration = 0.1
                    }
                    
                    gifDurations.append(duration)
                } else {
                    gifDurations.append(0.1)
                }
            }
        }
        
        totalFrames = gifImages.count
        
        if totalFrames > 0 {
            print("✅ 成功加载GIF，共\(totalFrames)帧")
            currentFrameIndex = 0
            currentImage = gifImages.first
        } else {
            print("❌ GIF文件没有有效帧")
            // 清空当前状态
            gifImages.removeAll()
            gifDurations.removeAll()
            totalFrames = 0
            currentImage = nil
        }
    }
    
    // MARK: - 创建默认动画 (已删除，不再使用)
    
    // MARK: - 播放动画
    func play() {
        guard totalFrames > 0 else { return }
        
        isPlaying = true
        animationTimer?.invalidate()
        
        playNextFrame()
    }
    
    // MARK: - 播放下一帧
    private func playNextFrame() {
        guard isPlaying, currentFrameIndex < gifDurations.count else { return }
        
        let duration = gifDurations[currentFrameIndex]
        
        animationTimer = Timer.scheduledTimer(withTimeInterval: duration, repeats: false) { [weak self] _ in
            self?.nextFrame()
        }
    }
    
    // MARK: - 下一帧
    private func nextFrame() {
        currentFrameIndex = (currentFrameIndex + 1) % totalFrames
        currentImage = gifImages[currentFrameIndex]
        
        if isPlaying {
            playNextFrame()
        }
    }
    
    // MARK: - 暂停动画
    func pause() {
        isPlaying = false
        animationTimer?.invalidate()
    }
    
    // MARK: - 停止动画
    func stop() {
        isPlaying = false
        animationTimer?.invalidate()
        currentFrameIndex = 0
        currentImage = gifImages.first
    }
    
    // MARK: - 跳转到指定帧
    func seekToFrame(_ frame: Int) {
        guard frame >= 0 && frame < totalFrames else { return }
        currentFrameIndex = frame
        currentImage = gifImages[currentFrameIndex]
    }
    
    // MARK: - 获取动画信息
    func getAnimationInfo() -> (totalFrames: Int, currentFrame: Int, averageDuration: TimeInterval)? {
        guard totalFrames > 0 else { return nil }
        
        let averageDuration = gifDurations.reduce(0, +) / Double(gifDurations.count)
        return (totalFrames: totalFrames, currentFrame: currentFrameIndex, averageDuration: averageDuration)
    }
    
    // MARK: - 获取进度
    func getProgress() -> Double {
        guard totalFrames > 0 else { return 0.0 }
        return Double(currentFrameIndex) / Double(totalFrames)
    }
    
    // MARK: - 获取可用GIF数量
    func getAvailableGIFCount() -> Int {
        return 1 // 目前只有1个GIF
    }
    
    // MARK: - 检查GIF文件是否存在
    func checkGIFFileExists(named gifName: String) -> Bool {
        return Bundle.main.url(forResource: gifName, withExtension: "gif") != nil
    }
} 

----

----
FilePath: ming-ling-watch-os Watch App/Utils/NotificationUtils.swift
Lines: 92
import SwiftUI

// MARK: - 通知工具类
class NotificationUtils {
    
    // MARK: - 通知类型
    enum NotificationType: String, CaseIterable {
        case suggestion = "建议"
        case completion = "完成"
        
        var title: String {
            return self.rawValue
        }
    }
    
    // MARK: - 获取建议通知内容
    static func getSuggestionContent(for element: String, taskType: TaskType) -> NotificationContent? {
        guard let suggestion = ReminderContentManager.shared.getSuggestionContent(for: taskType, element: element) else {
            return nil
        }
        
        let themeConfig = PetUtils.getElementThemeConfig(for: element)
        
        return NotificationContent(
            title: taskType.title,
            message: suggestion.message,
            element: element,
            themeConfig: themeConfig,
            type: .suggestion
        )
    }
    
    // MARK: - 获取完成通知内容
    static func getCompletionContent(for element: String, taskType: TaskType) -> NotificationContent? {
        guard let completion = ReminderContentManager.shared.getCompletionContent(for: taskType, element: element) else {
            return nil
        }
        
        let themeConfig = PetUtils.getElementThemeConfig(for: element)
        
        return NotificationContent(
            title: taskType.title,
            message: completion.message,
            element: element,
            themeConfig: themeConfig,
            type: .completion
        )
    }
    
    // MARK: - 随机获取建议通知内容
    static func getRandomSuggestionContent(for element: String) -> NotificationContent? {
        guard let (taskType, suggestion) = ReminderContentManager.shared.getRandomSuggestionContent(for: element) else {
            return nil
        }
        
        let themeConfig = PetUtils.getElementThemeConfig(for: element)
        
        return NotificationContent(
            title: taskType.title,
            message: suggestion.message,
            element: element,
            themeConfig: themeConfig,
            type: .suggestion
        )
    }
    
    // MARK: - 随机获取完成通知内容
    static func getRandomCompletionContent(for element: String) -> NotificationContent? {
        guard let (taskType, completion) = ReminderContentManager.shared.getRandomCompletionContent(for: element) else {
            return nil
        }
        
        let themeConfig = PetUtils.getElementThemeConfig(for: element)
        
        return NotificationContent(
            title: taskType.title,
            message: completion.message,
            element: element,
            themeConfig: themeConfig,
            type: .completion
        )
    }
}

// MARK: - 通知内容模型
struct NotificationContent {
    let title: String
    let message: String
    let element: String
    let themeConfig: ElementThemeConfig
    let type: NotificationUtils.NotificationType
} 
----

----
FilePath: ming-ling-watch-os Watch App/Utils/PetUtils.swift
Lines: 138
import SwiftUI

// MARK: - 宠物工具类
class PetUtils {
    
    // MARK: - 获取宠物图片名称
    static func getPetImageName(for element: String) -> String {
        switch element {
        case "金":
            return "jinjin"
        case "木":
            return "mumu"
        case "水":
            return "shuishui"
        case "火":
            return "huohuo"
        case "土":
            return "tutu"
        default:
            return "tutu"
        }
    }
    
    // MARK: - 获取宠物说话图片名称
    static func getPetSpeakImageName(for element: String) -> String {
        return "\(getPetImageName(for: element))_speak"
    }
    
    // MARK: - 获取GIF动画名称
    static func getGIFName(for element: String, intimacyGrade: Int, emotion: String) -> String {
        // 暂时所有五行都使用mumu
        let petName = "mumu"
        return "\(petName)/gif/\(emotion)/\(intimacyGrade)"
    }
    
    // MARK: - 获取宠物GIF动画名称（简化版本）
    static func getPetGIFName(for element: String) -> String {
        // 暂时所有五行都使用mumu的happy动画
        return "GIFs/mumu/happy/1"
    }
    
    // MARK: - 获取宠物GIF动画名称（根据亲密度等级）
    static func getPetGIFName(for element: String, intimacyGrade: Int) -> String {
        // 根据亲密度等级选择GIF文件
        let gifNumber: Int
        switch intimacyGrade {
        case 1:
            gifNumber = 1
        case 2:
            gifNumber = 2
        case 3:
            gifNumber = 3
        default:
            gifNumber = 1
        }
        
        // 暂时所有五行都使用mumu
        return "GIFs/mumu/happy/\(gifNumber)"
    }
    
    // MARK: - 获取宠物图片名称（根据亲密度）
    static func getPetImageName(for element: String, intimacyGrade: Int) -> String {
        // 暂时所有五行都使用mumu
        let petName = "mumu"
        return "\(petName)/image/\(intimacyGrade)"
    }
    
    // MARK: - 获取元素主题配置
    static func getElementThemeConfig(for element: String) -> ElementThemeConfig {
        switch element {
        case "金":
            return ElementThemeConfig(
                primaryColor: Color(hex: "FFD700"),
                secondaryColor: Color(hex: "FFF8DC"),
                textColor: Color(hex: "8B4513"),
                backgroundColor: Color(hex: "FFFACD")
            )
        case "木":
            return ElementThemeConfig(
                primaryColor: Color(hex: "228B22"),
                secondaryColor: Color(hex: "F0FFF0"),
                textColor: Color(hex: "006400"),
                backgroundColor: Color(hex: "E0F7E0")
            )
        case "水":
            return ElementThemeConfig(
                primaryColor: Color(hex: "4169E1"),
                secondaryColor: Color(hex: "F0F8FF"),
                textColor: Color(hex: "000080"),
                backgroundColor: Color(hex: "E6F3FF")
            )
        case "火":
            return ElementThemeConfig(
                primaryColor: Color(hex: "DC143C"),
                secondaryColor: Color(hex: "FFF5EE"),
                textColor: Color(hex: "8B0000"),
                backgroundColor: Color(hex: "FFE6E6")
            )
        case "土":
            return ElementThemeConfig(
                primaryColor: Color(hex: "8B4513"),
                secondaryColor: Color(hex: "F5F5DC"),
                textColor: Color(hex: "654321"),
                backgroundColor: Color(hex: "F0E6D2")
            )
        default:
            return ElementThemeConfig(
                primaryColor: Color(hex: "8B4513"),
                secondaryColor: Color(hex: "F5F5DC"),
                textColor: Color(hex: "654321"),
                backgroundColor: Color(hex: "F0E6D2")
            )
        }
    }
    
    // MARK: - 获取元素背景颜色
    static func getElementBackgroundColor(for element: String) -> Color {
        return getElementThemeConfig(for: element).backgroundColor
    }
    
    // MARK: - 获取元素对话框颜色
    static func getElementDialogColor(for element: String) -> Color {
        return getElementThemeConfig(for: element).primaryColor
    }
    
    // MARK: - 获取元素文本颜色
    static func getElementTextColor(for element: String) -> Color {
        return getElementThemeConfig(for: element).textColor
    }
}

// MARK: - 元素主题配置
struct ElementThemeConfig {
    let primaryColor: Color
    let secondaryColor: Color
    let textColor: Color
    let backgroundColor: Color
} 
----

----
FilePath: ming-ling-watch-os Watch App/Utils/ReminderContentManager.swift
Lines: 191
import Foundation

// MARK: - 任务类型枚举
enum TaskType: String, CaseIterable {
    case sunExposure = "晒太阳"
    case stress = "压力大"
    case sedentary = "久坐"
    case exercise = "运动检测"
    case sleep = "睡眠监测"
    
    var title: String {
        return self.rawValue
    }
}

// MARK: - 通知类型枚举
enum NotificationType: String, CaseIterable {
    case suggestion = "建议"
    case completion = "完成"
    
    var title: String {
        return self.rawValue
    }
}

// MARK: - 元素类型
typealias ElementType = String

// MARK: - 建议内容结构
struct SuggestionContent {
    let message: String
}

// MARK: - 完成内容结构
struct CompletionContent {
    let message: String
    let intimacyPoints: Int
}

// MARK: - 任务内容结构
struct TaskContent {
    let suggestions: [ElementType: SuggestionContent]
    let completions: [ElementType: CompletionContent]
}

// MARK: - 提醒内容管理器
class ReminderContentManager {
    static let shared = ReminderContentManager()
    
    private init() {}
    
    // MARK: - 提醒内容数据
    private let reminderContents: [TaskType: TaskContent] = [
        .sunExposure: TaskContent(
            suggestions: [
                "金": SuggestionContent(message: "阳光正好，出去晒15分钟润肺气。金需要适度日晒。"),
                "木": SuggestionContent(message: "阳光助木气生发，出去走走舒肝气吧。"),
                "水": SuggestionContent(message: "太阳能温肾阳，去晒晒背补充阳气～"),
                "火": SuggestionContent(message: "阳光充足但不烈，适合补充心阳！"),
                "土": SuggestionContent(message: "晒太阳健脾胃，阳光下土气运化更好。")
            ],
            completions: [
                "金": CompletionContent(message: "很好，金气在阳光下得到滋润。", intimacyPoints: 20),
                "木": CompletionContent(message: "阳光让肝气舒展，状态不错。", intimacyPoints: 20),
                "水": CompletionContent(message: "晒太阳补肾阳，真棒～", intimacyPoints: 20),
                "火": CompletionContent(message: "心阳充足了！能量满满！", intimacyPoints: 20),
                "土": CompletionContent(message: "脾土得到阳气，消化会更好。", intimacyPoints: 20)
            ]
        ),
        .stress: TaskContent(
            suggestions: [
                "金": SuggestionContent(message: "肺气需要调理。金属性压力大时容易呼吸短促。"),
                "木": SuggestionContent(message: "肝气有点郁结了。木属性要保持心情舒畅。"),
                "水": SuggestionContent(message: "肾气不足了。水属性最忌讳熬夜伤肾。"),
                "火": SuggestionContent(message: "心火有点旺。火属性的人要注意清心。"),
                "土": SuggestionContent(message: "脾胃受压力影响了。土属性重在调理中焦。")
            ],
            completions: [
                "金": CompletionContent(message: "金气恢复不错。", intimacyPoints: 20),
                "木": CompletionContent(message: "肝气舒畅多了。", intimacyPoints: 20),
                "水": CompletionContent(message: "肾气在恢复呢～", intimacyPoints: 20),
                "火": CompletionContent(message: "心火平稳了！很好！", intimacyPoints: 20),
                "土": CompletionContent(message: "脾土安定了，不错。", intimacyPoints: 20)
            ]
        ),
        .sedentary: TaskContent(
            suggestions: [
                "金": SuggestionContent(message: "久坐肺气不畅，金需流通。"),
                "木": SuggestionContent(message: "坐久了筋脉不通，木喜舒展。"),
                "水": SuggestionContent(message: "久坐伤肾，水需流动～"),
                "火": SuggestionContent(message: "血脉要不通了！火主循环！"),
                "土": SuggestionContent(message: "久坐困脾，土气需运化。")
            ],
            completions: [
                "金": CompletionContent(message: "活动后肺气通畅多了。", intimacyPoints: 20),
                "木": CompletionContent(message: "筋骨舒展，很好。", intimacyPoints: 20),
                "水": CompletionContent(message: "动起来了～肾气也活了～", intimacyPoints: 20),
                "火": CompletionContent(message: "血液循环起来了！棒！", intimacyPoints: 20),
                "土": CompletionContent(message: "脾胃得到运化，好。", intimacyPoints: 20)
            ]
        ),
        .exercise: TaskContent(
            suggestions: [
                "金": SuggestionContent(message: "该运动了，金主气，需要流通。"),
                "木": SuggestionContent(message: "运动舒肝，让筋骨舒展。"),
                "水": SuggestionContent(message: "运动补肾，让水气流动～"),
                "火": SuggestionContent(message: "运动助心火，让血脉通畅！"),
                "土": SuggestionContent(message: "运动健脾胃，让土气运化。")
            ],
            completions: [
                "金": CompletionContent(message: "运动后记得调息，金主气。", intimacyPoints: 20),
                "木": CompletionContent(message: "运动舒肝，记得放松。", intimacyPoints: 20),
                "水": CompletionContent(message: "运动出汗，该补充水分了～", intimacyPoints: 20),
                "火": CompletionContent(message: "运动后心率恢复得不错！", intimacyPoints: 20),
                "土": CompletionContent(message: "运动助脾运化，很好。", intimacyPoints: 20)
            ]
        ),
        .sleep: TaskContent(
            suggestions: [
                "金": SuggestionContent(message: "该准备睡觉了，养肺阴。"),
                "木": SuggestionContent(message: "早睡养肝血，准备休息吧。"),
                "水": SuggestionContent(message: "早睡最养肾～该准备了～"),
                "火": SuggestionContent(message: "让心神安定，准备入睡！"),
                "土": SuggestionContent(message: "脾胃需要休息，早点睡。")
            ],
            completions: [
                "金": CompletionContent(message: "昨晚睡眠不足，今天注意养肺。", intimacyPoints: 20),
                "木": CompletionContent(message: "睡眠不足伤肝，今天要平和。", intimacyPoints: 20),
                "水": CompletionContent(message: "睡眠不足伤肾精，要补充哦～", intimacyPoints: 20),
                "火": CompletionContent(message: "睡眠影响心神，今天慢一点！", intimacyPoints: 20),
                "土": CompletionContent(message: "睡眠不足影响脾胃，注意饮食。", intimacyPoints: 20)
            ]
        )
    ]
    
    // MARK: - 获取建议内容
    func getSuggestionContent(for taskType: TaskType, element: ElementType) -> SuggestionContent? {
        guard let taskContent = reminderContents[taskType],
              let suggestion = taskContent.suggestions[element] else {
            return nil
        }
        return suggestion
    }
    
    // MARK: - 获取完成内容
    func getCompletionContent(for taskType: TaskType, element: ElementType) -> CompletionContent? {
        guard let taskContent = reminderContents[taskType],
              let completion = taskContent.completions[element] else {
            return nil
        }
        return completion
    }
    
    // MARK: - 随机获取建议内容
    func getRandomSuggestionContent(for element: ElementType) -> (TaskType, SuggestionContent)? {
        let availableTasks = TaskType.allCases.filter { taskType in
            getSuggestionContent(for: taskType, element: element) != nil
        }
        
        guard let randomTask = availableTasks.randomElement(),
              let suggestion = getSuggestionContent(for: randomTask, element: element) else {
            return nil
        }
        
        return (randomTask, suggestion)
    }
    
    // MARK: - 随机获取完成内容
    func getRandomCompletionContent(for element: ElementType) -> (TaskType, CompletionContent)? {
        let availableTasks = TaskType.allCases.filter { taskType in
            getCompletionContent(for: taskType, element: element) != nil
        }
        
        guard let randomTask = availableTasks.randomElement(),
              let completion = getCompletionContent(for: randomTask, element: element) else {
            return nil
        }
        
        return (randomTask, completion)
    }
    
    // MARK: - 获取所有任务类型
    func getAllTaskTypes() -> [TaskType] {
        return Array(reminderContents.keys)
    }
    
    // MARK: - 检查任务类型是否支持指定元素
    func isTaskSupported(for taskType: TaskType, element: ElementType) -> Bool {
        return getSuggestionContent(for: taskType, element: element) != nil
    }
} 
----

----
FilePath: ming-ling-watch-os Watch App/Views/BaziDetailView.swift
Lines: 338
import SwiftUI

struct BaziDetailView: View {
    let baziData: BaziData
    let userElement: String
    
    var body: some View {
        ScrollView {
            VStack(spacing: 20) {
                // 基本信息
                basicInfoSection
                
                // 八字信息
                baziInfoSection
                
                // 称骨信息
                chengguSection
                
                // 五行分析
                wuxingSection
                
                // 喜用神
                xiyongshenSection
                
                // 姻缘信息
                if let yinyuan = baziData.yinyuan {
                    yinyuanSection(yinyuan)
                }
                
                // 财运信息
                if let caiyun = baziData.caiyun {
                    caiyunSection(caiyun)
                }
                
                // 命运批示
                if let mingyun = baziData.mingyun {
                    mingyunSection(mingyun)
                }
                
                Spacer(minLength: 20)
            }
            .padding(.horizontal)
        }
        .navigationTitle("Bazi Analysis")
        .navigationBarTitleDisplayMode(.inline)
    }
    
    // MARK: - 基本信息
    private var basicInfoSection: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text("基本信息")
                .font(.headline)
                .fontWeight(.semibold)
            
            VStack(alignment: .leading, spacing: 8) {
                InfoRow(title: "姓名", value: baziData.base_info.name)
                InfoRow(title: "性别", value: baziData.base_info.sex)
                InfoRow(title: "公历", value: baziData.base_info.gongli)
                InfoRow(title: "农历", value: baziData.base_info.nongli)
                InfoRow(title: "起运", value: baziData.base_info.qiyun)
                InfoRow(title: "交运", value: baziData.base_info.jiaoyun)
                InfoRow(title: "正格", value: baziData.base_info.zhengge)
                InfoRow(title: "五行喜忌", value: baziData.base_info.wuxing_xiji)
            }
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(Color.blue.opacity(0.1))
        )
    }
    
    // MARK: - 八字信息
    private var baziInfoSection: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text("八字信息")
                .font(.headline)
                .fontWeight(.semibold)
            
            VStack(alignment: .leading, spacing: 8) {
                InfoRow(title: "八字", value: baziData.bazi_info.bazi)
                InfoRow(title: "纳音", value: baziData.bazi_info.na_yin)
                InfoRow(title: "空亡", value: baziData.bazi_info.kw)
                
                VStack(alignment: .leading, spacing: 4) {
                    Text("十神:")
                        .font(.caption)
                        .fontWeight(.semibold)
                    
                    ForEach(Array(baziData.bazi_info.tg_cg_god.enumerated()), id: \.offset) { index, god in
                        HStack {
                            Text("•")
                                .foregroundColor(.blue)
                            Text("\(["年", "月", "日", "时"][index]): \(god)")
                                .font(.caption)
                                .foregroundColor(.secondary)
                        }
                    }
                }
            }
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(Color.green.opacity(0.1))
        )
    }
    
    // MARK: - 称骨信息
    private var chengguSection: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text("称骨分析")
                .font(.headline)
                .fontWeight(.semibold)
            
            VStack(alignment: .leading, spacing: 8) {
                InfoRow(title: "总重量", value: baziData.chenggu.total_weight)
                InfoRow(title: "年重量", value: baziData.chenggu.year_weight)
                InfoRow(title: "月重量", value: baziData.chenggu.month_weight)
                InfoRow(title: "日重量", value: baziData.chenggu.day_weight)
                InfoRow(title: "时重量", value: baziData.chenggu.hour_weight)
                
                VStack(alignment: .leading, spacing: 4) {
                    Text("描述:")
                        .font(.caption)
                        .fontWeight(.semibold)
                    Text(baziData.chenggu.description)
                        .font(.caption)
                        .foregroundColor(.secondary)
                        .multilineTextAlignment(.leading)
                }
            }
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(Color.orange.opacity(0.1))
        )
    }
    
    // MARK: - 五行分析
    private var wuxingSection: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text("五行分析")
                .font(.headline)
                .fontWeight(.semibold)
            
            VStack(alignment: .leading, spacing: 8) {
                InfoRow(title: "简要描述", value: baziData.wuxing.simple_desc)
                InfoRow(title: "详细描述", value: baziData.wuxing.detail_desc)
                
                VStack(alignment: .leading, spacing: 4) {
                    Text("简要说明:")
                        .font(.caption)
                        .fontWeight(.semibold)
                    Text(baziData.wuxing.simple_description)
                        .font(.caption)
                        .foregroundColor(.secondary)
                        .multilineTextAlignment(.leading)
                }
            }
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(Color.purple.opacity(0.1))
        )
    }
    
    // MARK: - 喜用神
    private var xiyongshenSection: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text("喜用神")
                .font(.headline)
                .fontWeight(.semibold)
            
            VStack(alignment: .leading, spacing: 8) {
                InfoRow(title: "强弱", value: baziData.xiyongshen.qiangruo)
                InfoRow(title: "喜用神", value: baziData.xiyongshen.xiyongshen)
                InfoRow(title: "忌神", value: baziData.xiyongshen.jishen)
                InfoRow(title: "同类", value: baziData.xiyongshen.tonglei)
                InfoRow(title: "异类", value: baziData.xiyongshen.yilei)
                InfoRow(title: "日主天干", value: baziData.xiyongshen.rizhu_tiangan)
                
                VStack(alignment: .leading, spacing: 4) {
                    Text("描述:")
                        .font(.caption)
                        .fontWeight(.semibold)
                    Text(baziData.xiyongshen.xiyongshen_desc)
                        .font(.caption)
                        .foregroundColor(.secondary)
                        .multilineTextAlignment(.leading)
                }
                
                // 五行统计
                VStack(alignment: .leading, spacing: 4) {
                    Text("五行统计:")
                        .font(.caption)
                        .fontWeight(.semibold)
                    
                    HStack(spacing: 12) {
                        WuXingCountView(element: "金", count: baziData.xiyongshen.jin_number, score: baziData.xiyongshen.jin_score_percent)
                        WuXingCountView(element: "木", count: baziData.xiyongshen.mu_number, score: baziData.xiyongshen.mu_score_percent)
                        WuXingCountView(element: "水", count: baziData.xiyongshen.shui_number, score: baziData.xiyongshen.shui_score_percent)
                        WuXingCountView(element: "火", count: baziData.xiyongshen.huo_number, score: baziData.xiyongshen.huo_score_percent)
                        WuXingCountView(element: "土", count: baziData.xiyongshen.tu_number, score: baziData.xiyongshen.tu_score_percent)
                    }
                }
            }
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(Color.red.opacity(0.1))
        )
    }
    
    // MARK: - 姻缘信息
    private func yinyuanSection(_ yinyuan: YinyuanInfo) -> some View {
        VStack(alignment: .leading, spacing: 12) {
            Text("姻缘")
                .font(.headline)
                .fontWeight(.semibold)
            
            VStack(alignment: .leading, spacing: 8) {
                Text(yinyuan.sanshishu_yinyuan)
                    .font(.caption)
                    .foregroundColor(.secondary)
                    .multilineTextAlignment(.leading)
            }
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(Color.pink.opacity(0.1))
        )
    }
    
    // MARK: - 财运信息
    private func caiyunSection(_ caiyun: CaiyunInfo) -> some View {
        VStack(alignment: .leading, spacing: 12) {
            Text("财运")
                .font(.headline)
                .fontWeight(.semibold)
            
            VStack(alignment: .leading, spacing: 8) {
                InfoRow(title: "简要", value: caiyun.sanshishu_caiyun.simple_desc)
                
                VStack(alignment: .leading, spacing: 4) {
                    Text("详细:")
                        .font(.caption)
                        .fontWeight(.semibold)
                    Text(caiyun.sanshishu_caiyun.detail_desc)
                        .font(.caption)
                        .foregroundColor(.secondary)
                        .multilineTextAlignment(.leading)
                }
            }
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(Color.yellow.opacity(0.1))
        )
    }
    
    // MARK: - 命运批示
    private func mingyunSection(_ mingyun: MingyunInfo) -> some View {
        VStack(alignment: .leading, spacing: 12) {
            Text("命运")
                .font(.headline)
                .fontWeight(.semibold)
            
            VStack(alignment: .leading, spacing: 8) {
                Text(mingyun.sanshishu_mingyun)
                    .font(.caption)
                    .foregroundColor(.secondary)
                    .multilineTextAlignment(.leading)
            }
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(Color.indigo.opacity(0.1))
        )
    }
}

// MARK: - 信息行视图
struct InfoRow: View {
    let title: String
    let value: String
    
    var body: some View {
        HStack {
            Text(title)
                .font(.caption)
                .fontWeight(.semibold)
                .foregroundColor(.primary)
            
            Spacer()
            
            Text(value)
                .font(.caption)
                .foregroundColor(.secondary)
                .multilineTextAlignment(.trailing)
        }
    }
}

// MARK: - 五行统计视图
struct WuXingCountView: View {
    let element: String
    let count: Int
    let score: String
    
    var body: some View {
        VStack(spacing: 2) {
            Text(element)
                .font(.caption2)
                .fontWeight(.bold)
            
            Text("\(count)")
                .font(.caption2)
                .foregroundColor(.secondary)
            
            Text(score)
                .font(.caption2)
                .foregroundColor(.blue)
        }
        .frame(maxWidth: .infinity)
        .padding(.vertical, 4)
        .background(
            RoundedRectangle(cornerRadius: 6)
                .fill(Color.gray.opacity(0.1))
        )
    }
} 
----

----
FilePath: ming-ling-watch-os Watch App/Views/BirthdaySelectionView.swift
Lines: 376
import SwiftUI

struct BirthdaySelectionView: View {
    @StateObject private var profileManager = UserProfileManager.shared
    private let baziService = BaziAPIService()
    
    @State private var selectedDate = Date()
    @State private var selectedSex = 0 // 0男 1女
    @State private var showingDatePicker = false
    @State private var selectedFiveElements: FiveElements?
    @State private var selectedBaziData: BaziData?
    @State private var error: String?
    
    var body: some View {
        ScrollView {
            VStack(spacing: 20) {
                // 标题
                VStack(spacing: 8) {
                    Text("欢迎使用健康助手")
                        .font(.title2)
                        .fontWeight(.bold)
                        .multilineTextAlignment(.center)
                    
                    Text("让我们先了解您的体质")
                        .font(.caption)
                        .foregroundColor(.secondary)
                        .multilineTextAlignment(.center)
                }
                .padding(.top, 20)
                
                // 性别选择
                VStack(spacing: 12) {
                    Text("性别")
                        .font(.headline)
                        .fontWeight(.semibold)
                    
                    HStack(spacing: 20) {
                        Button(action: {
                            selectedSex = 0
                        }) {
                            HStack {
                                Image(systemName: selectedSex == 0 ? "checkmark.circle.fill" : "circle")
                                    .foregroundColor(selectedSex == 0 ? .blue : .gray)
                                Text("男")
                                    .foregroundColor(selectedSex == 0 ? .primary : .secondary)
                            }
                        }
                        .buttonStyle(PlainButtonStyle())
                        
                        Button(action: {
                            selectedSex = 1
                        }) {
                            HStack {
                                Image(systemName: selectedSex == 1 ? "checkmark.circle.fill" : "circle")
                                    .foregroundColor(selectedSex == 1 ? .blue : .gray)
                                Text("女")
                                    .foregroundColor(selectedSex == 1 ? .primary : .secondary)
                            }
                        }
                        .buttonStyle(PlainButtonStyle())
                    }
                }
                
                // 生日选择
                VStack(spacing: 12) {
                    Text("选择您的生日")
                        .font(.headline)
                        .fontWeight(.semibold)
                    
                    Button(action: {
                        showingDatePicker = true
                    }) {
                        HStack {
                            Image(systemName: "calendar")
                                .foregroundColor(.blue)
                            
                            Text(formatDate(selectedDate))
                                .foregroundColor(.primary)
                            
                            Spacer()
                            
                            Image(systemName: "chevron.right")
                                .foregroundColor(.secondary)
                                .font(.caption)
                        }
                        .padding()
                        .background(
                            RoundedRectangle(cornerRadius: 12)
                                .fill(Color.gray.opacity(0.1))
                                .overlay(
                                    RoundedRectangle(cornerRadius: 12)
                                        .stroke(Color.blue.opacity(0.3), lineWidth: 1)
                                )
                        )
                    }
                    .buttonStyle(PlainButtonStyle())
                }
                
                // 获取五行属性按钮
                Button(action: {
                    Task {
                        await getFiveElements()
                    }
                }) {
                    HStack {
                        if baziService.isLoading {
                            ProgressView()
                                .scaleEffect(0.8)
                                .foregroundColor(.white)
                        } else {
                            Image(systemName: "sparkles")
                                .foregroundColor(.white)
                        }
                        
                        Text(baziService.isLoading ? "分析中..." : "获取我的体质")
                            .fontWeight(.semibold)
                            .foregroundColor(.white)
                    }
                    .frame(maxWidth: .infinity)
                    .padding()
                    .background(
                        RoundedRectangle(cornerRadius: 12)
                            .fill(baziService.isLoading ? Color.gray : Color.blue)
                    )
                }
                .disabled(baziService.isLoading)
                .buttonStyle(PlainButtonStyle())
                
                // 错误信息
                if let error = error {
                    Text(error)
                        .font(.caption)
                        .foregroundColor(.red)
                        .multilineTextAlignment(.center)
                        .padding(.horizontal)
                }
                
                // 五行属性显示
                if let fiveElements = selectedFiveElements, let baziData = selectedBaziData {
                    VStack(spacing: 16) {
                        Text("您的体质")
                            .font(.headline)
                            .fontWeight(.semibold)
                        
                        VStack(spacing: 12) {
                            HStack {
                                Circle()
                                    .fill(getElementColor(for: fiveElements.primary))
                                    .frame(width: 20, height: 20)
                                
                                Text(fiveElements.primary)
                                    .font(.title3)
                                    .fontWeight(.bold)
                                
                                Spacer()
                            }
                            
                            Text(fiveElements.description)
                                .font(.caption)
                                .foregroundColor(.secondary)
                                .multilineTextAlignment(.leading)
                            
                            VStack(alignment: .leading, spacing: 4) {
                                Text("健康建议:")
                                    .font(.caption)
                                    .fontWeight(.semibold)
                                
                                ForEach(getHealthTips(for: fiveElements.primary), id: \.self) { tip in
                                    HStack(alignment: .top) {
                                        Text("•")
                                            .foregroundColor(.blue)
                                        Text(tip)
                                            .font(.caption2)
                                            .foregroundColor(.secondary)
                                    }
                                }
                            }
                        }
                        .padding()
                        .background(
                            RoundedRectangle(cornerRadius: 12)
                                .fill(Color.gray.opacity(0.1))
                                .overlay(
                                    RoundedRectangle(cornerRadius: 12)
                                        .stroke(getElementColor(for: fiveElements.primary).opacity(0.3), lineWidth: 1)
                                )
                        )
                        
                        // 宠物推荐
                        VStack(spacing: 12) {
                            Text("推荐宠物")
                                .font(.headline)
                                .fontWeight(.semibold)
                            
                            VStack(spacing: 8) {
                                Text(getPetName(for: fiveElements.primary))
                                    .font(.title3)
                                    .fontWeight(.bold)
                                    .foregroundColor(getElementColor(for: fiveElements.primary))
                                
                                Text(getPetDescription(for: fiveElements.primary))
                                    .font(.caption)
                                    .foregroundColor(.secondary)
                                    .multilineTextAlignment(.center)
                            }
                            .padding()
                            .background(
                                RoundedRectangle(cornerRadius: 12)
                                    .fill(getElementColor(for: fiveElements.primary).opacity(0.1))
                            )
                        }
                        
                        // 进入应用按钮
                        Button(action: {
                            profileManager.setProfile(birthday: selectedDate, sex: selectedSex, fiveElements: fiveElements, baziData: baziData)
                        }) {
                            HStack {
                                Image(systemName: "heart.fill")
                                    .foregroundColor(.white)
                                
                                Text("开始我的健康之旅")
                                    .fontWeight(.semibold)
                                    .foregroundColor(.white)
                            }
                            .frame(maxWidth: .infinity)
                            .padding()
                            .background(
                                RoundedRectangle(cornerRadius: 12)
                                    .fill(getElementColor(for: fiveElements.primary))
                            )
                        }
                        .buttonStyle(PlainButtonStyle())
                    }
                }
                
                Spacer(minLength: 20)
            }
            .padding(.horizontal)
        }
        .sheet(isPresented: $showingDatePicker) {
            DatePickerView(selectedDate: $selectedDate)
        }
    }
    
    // MARK: - 获取五行属性
    private func getFiveElements() async {
        do {
            let (fiveElements, baziData) = try await baziService.getFiveElements(birthday: selectedDate, sex: selectedSex)
            await MainActor.run {
                selectedFiveElements = fiveElements
                selectedBaziData = baziData
                error = nil
            }
        } catch let errorMessage {
            await MainActor.run {
                error = errorMessage.localizedDescription
            }
        }
    }
    
    // MARK: - 格式化日期
    private func formatDate(_ date: Date) -> String {
        let formatter = DateFormatter()
        formatter.dateStyle = .medium
        return formatter.string(from: date)
    }
    
    // MARK: - 获取元素颜色
    private func getElementColor(for element: String) -> Color {
        switch element {
        case "金":
            return Color(hex: "FFD700")
        case "木":
            return Color(hex: "228B22")
        case "水":
            return Color(hex: "4169E1")
        case "火":
            return Color(hex: "DC143C")
        case "土":
            return Color(hex: "8B4513")
        default:
            return Color.blue
        }
    }
    
    // MARK: - 获取健康建议
    private func getHealthTips(for element: String) -> [String] {
        switch element {
        case "金":
            return ["注意呼吸调理", "保持心情舒畅", "适度运动"]
        case "木":
            return ["保持心情舒畅", "适度运动", "注意休息"]
        case "水":
            return ["注意保暖", "充足睡眠", "适度饮水"]
        case "火":
            return ["保持心情平静", "适度运动", "注意饮食"]
        case "土":
            return ["注意饮食调理", "适度运动", "保持规律作息"]
        default:
            return ["保持健康，注意休息"]
        }
    }
    
    // MARK: - 获取宠物名称
    private func getPetName(for element: String) -> String {
        switch element {
        case "金":
            return "金金"
        case "木":
            return "木木"
        case "水":
            return "水水"
        case "火":
            return "火火"
        case "土":
            return "土土"
        default:
            return "土土"
        }
    }
    
    // MARK: - 获取宠物描述
    private func getPetDescription(for element: String) -> String {
        switch element {
        case "金":
            return "金属性宠物，有助于调理肺气"
        case "木":
            return "木属性宠物，有助于舒展肝气"
        case "水":
            return "水属性宠物，有助于温润肾气"
        case "火":
            return "火属性宠物，有助于清凉心气"
        case "土":
            return "土属性宠物，有助于温和脾气"
        default:
            return "健康助手宠物"
        }
    }
}

// MARK: - 日期选择器视图
struct DatePickerView: View {
    @Binding var selectedDate: Date
    @Environment(\.dismiss) private var dismiss
    
    var body: some View {
        NavigationView {
            VStack {
                DatePicker(
                    "Select Birthday",
                    selection: $selectedDate,
                    displayedComponents: .date
                )
                .datePickerStyle(WheelDatePickerStyle())
                .labelsHidden()
                
                HStack {
                    Button("取消") {
                        dismiss()
                    }
                    .buttonStyle(.bordered)
                    
                    Spacer()
                    
                    Button("完成") {
                        dismiss()
                    }
                    .buttonStyle(.borderedProminent)
                }
                .padding()
            }
            .navigationTitle("Birthday")
            .navigationBarTitleDisplayMode(.inline)
        }
    }
} 
----

----
FilePath: ming-ling-watch-os Watch App/Views/GIFAnimationView.swift
Lines: 67
import SwiftUI

// MARK: - GIF动画视图
struct GIFAnimationView: View {
    let gifName: String
    let isPlaying: Bool
    
    @StateObject private var animationManager = GIFAnimationManager.shared
    
    init(gifName: String, isPlaying: Bool = true) {
        self.gifName = gifName
        self.isPlaying = isPlaying
    }
    
    var body: some View {
        GeometryReader { geometry in
            ZStack {
                if let image = animationManager.currentImage {
                    // 显示当前GIF帧
                    Image(uiImage: image)
                        .resizable()
                        .aspectRatio(contentMode: .fit)
                        .frame(width: geometry.size.width, height: geometry.size.height)
                } else {
                    // 加载中状态
                    ProgressView()
                        .progressViewStyle(CircularProgressViewStyle())
                        .scaleEffect(0.8)
                }
            }
            .frame(width: geometry.size.width, height: geometry.size.height)
        }
        .onAppear {
            // 加载GIF动画
            animationManager.loadGIF(named: gifName)
            
            if isPlaying {
                animationManager.play()
            }
        }
        .onDisappear {
            animationManager.stop()
        }
        .onChange(of: isPlaying) { newValue in
            if newValue {
                animationManager.play()
            } else {
                animationManager.pause()
            }
        }
    }
}



// MARK: - 预览
struct GIFAnimationView_Previews: PreviewProvider {
    static var previews: some View {
        VStack(spacing: 20) {
            GIFAnimationView(gifName: "animation1", isPlaying: true)
                .frame(width: 100, height: 100)
                .background(Color.gray.opacity(0.2))
                .clipShape(RoundedRectangle(cornerRadius: 12))
        }
        .padding()
    }
} 
----

----
FilePath: ming-ling-watch-os Watch App/Views/HealthCardView.swift
Lines: 69
import SwiftUI

// MARK: - 健康卡片视图
struct HealthCardView: View {
    let reminder: HealthReminder
    let healthData: String
    let userElement: String
    let isDarkMode: Bool
    
    init(reminder: HealthReminder, healthData: String, userElement: String, isDarkMode: Bool = false) {
        self.reminder = reminder
        self.healthData = healthData
        self.userElement = userElement
        self.isDarkMode = isDarkMode
    }
    
    var body: some View {
        VStack(spacing: 8) {
            Image(systemName: reminder.type.icon)
                .font(.title2)
                .foregroundColor(Color(hex: reminder.type.color))
            
            Text(reminder.type.rawValue)
                .font(.headline)
                .lineLimit(1)
                .minimumScaleFactor(0.8)
                .foregroundColor(isDarkMode ? .white : .primary)
            
            Text(healthData)
                .font(.caption2)
                .foregroundColor(isDarkMode ? .white.opacity(0.7) : .secondary)
                .lineLimit(2)
                .multilineTextAlignment(.center)
        }
        .frame(maxWidth: .infinity, minHeight: 80)
        .padding(8)
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(isDarkMode ? Color.gray.opacity(0.2) : Color.gray.opacity(0.1))
                .overlay(
                    RoundedRectangle(cornerRadius: 12)
                        .stroke(Color(hex: reminder.type.color).opacity(isDarkMode ? 0.5 : 0.3), lineWidth: 1)
                )
        )
        .contentShape(Rectangle())
    }
}

// MARK: - 预览
struct HealthCardView_Previews: PreviewProvider {
    static var previews: some View {
        VStack(spacing: 20) {
            HealthCardView(
                reminder: HealthReminder.allReminders[0],
                healthData: "测试数据",
                userElement: "金",
                isDarkMode: false
            )
            
            HealthCardView(
                reminder: HealthReminder.allReminders[1],
                healthData: "测试数据",
                userElement: "木",
                isDarkMode: true
            )
        }
        .padding()
    }
} 
----

----
FilePath: ming-ling-watch-os Watch App/Views/HealthDashboardPageView.swift
Lines: 311
import SwiftUI
import UserNotifications

// MARK: - 健康数据页面
struct HealthDashboardPageView: View {
    @StateObject private var profileManager = UserProfileManager.shared
    @StateObject private var healthKitManager = HealthKitManager.shared
    @StateObject private var environmentManager = EnvironmentSensorManager.shared
    @StateObject private var systemNotificationManager = SystemNotificationManager.shared
    @StateObject private var gifAnimationManager = GIFAnimationManager.shared
    
    @State private var isDelayedNotification: Bool = false
    
    var body: some View {
        ScrollView {
            VStack(spacing: 20) {
                // 问候语和压力状态
                greetingSection
                
                // 健康卡片
                healthCardsSection
                
                // 通知测试模块
                notificationTestSection
                
                // 设置入口
                settingsSection
                
                // 添加底部间距确保可以滚动到底部
                Spacer(minLength: 20)
            }
            .padding()
        }
        .scrollIndicators(.hidden)
        .background(PetUtils.getElementBackgroundColor(for: profileManager.userProfile.fiveElements?.primary ?? "金"))
        .onAppear {
            healthKitManager.requestAuthorization()
            profileManager.updateHealthStreak()
            // 设置通知代理
            UNUserNotificationCenter.current().delegate = systemNotificationManager
            
            // 延迟刷新数据，确保授权完成
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
                healthKitManager.objectWillChange.send()
            }
        }
    }
    
    // MARK: - 问候语区域
    private var greetingSection: some View {
        VStack(spacing: 12) {
            HStack(spacing: 12) {
                Circle()
                    .fill(PetUtils.getElementDialogColor(for: profileManager.userProfile.fiveElements?.primary ?? "金"))
                    .frame(width: 40, height: 40)
                    .overlay(
                        Image(systemName: "heart.fill")
                            .foregroundColor(PetUtils.getElementTextColor(for: profileManager.userProfile.fiveElements?.primary ?? "金"))
                            .font(.title3)
                    )
                
                VStack(alignment: .leading, spacing: 4) {
                    Text(profileManager.getGreeting())
                        .font(.headline)
                        .fontWeight(.semibold)
                        .multilineTextAlignment(.leading)
                        .foregroundColor(PetUtils.getElementTextColor(for: profileManager.userProfile.fiveElements?.primary ?? "金"))
                    
                    Text(profileManager.getStressStatusDescription())
                        .font(.caption)
                        .foregroundColor(PetUtils.getElementTextColor(for: profileManager.userProfile.fiveElements?.primary ?? "金").opacity(0.7))
                }
                
                Spacer()
            }
            .padding()
            .background(
                RoundedRectangle(cornerRadius: 16)
                    .fill(PetUtils.getElementDialogColor(for: profileManager.userProfile.fiveElements?.primary ?? "金").opacity(0.2))
                    .overlay(
                        RoundedRectangle(cornerRadius: 16)
                            .stroke(PetUtils.getElementDialogColor(for: profileManager.userProfile.fiveElements?.primary ?? "金").opacity(0.5), lineWidth: 1)
                    )
            )
        }
    }
    
    // MARK: - 健康卡片区域
    private var healthCardsSection: some View {
        VStack(spacing: 16) {
            Text("今日健康监测")
                .font(.headline)
                .fontWeight(.semibold)
                .frame(maxWidth: .infinity, alignment: .leading)
                .foregroundColor(PetUtils.getElementTextColor(for: profileManager.userProfile.fiveElements?.primary ?? "金"))
            
            LazyVGrid(columns: [
                GridItem(.flexible()),
                GridItem(.flexible())
            ], spacing: 12) {
                ForEach(HealthReminder.allReminders, id: \.id) { reminder in
                    NavigationLink(destination: HealthDetailView(
                        reminder: reminder, 
                        userElement: profileManager.userProfile.fiveElements?.primary ?? "金",
                        healthData: getHealthData(for: reminder.type)
                    )) {
                        HealthCardView(
                            reminder: reminder,
                            healthData: getHealthData(for: reminder.type),
                            userElement: profileManager.userProfile.fiveElements?.primary ?? "金",
                            isDarkMode: true
                        )
                    }
                    .buttonStyle(PlainButtonStyle())
                    .onTapGesture {
                        print("点击了健康卡片: \(reminder.type.rawValue)")
                    }
                }
            }
        }
    }
    
    // MARK: - 通知测试模块
    private var notificationTestSection: some View {
        VStack(spacing: 16) {
            Text("通知测试")
                .font(.headline)
                .fontWeight(.semibold)
                .frame(maxWidth: .infinity, alignment: .leading)
                .foregroundColor(PetUtils.getElementTextColor(for: profileManager.userProfile.fiveElements?.primary ?? "金"))
            
            VStack(spacing: 12) {
                // 延迟发送开关
                HStack {
                    Toggle("10秒后发送", isOn: $isDelayedNotification)
                        .toggleStyle(SwitchToggleStyle(tint: PetUtils.getElementDialogColor(for: profileManager.userProfile.fiveElements?.primary ?? "金")))
                        .font(.caption)
                        .foregroundColor(PetUtils.getElementTextColor(for: profileManager.userProfile.fiveElements?.primary ?? "金"))
                    
                    Spacer()
                }
                .padding(.horizontal, 4)
                
                // 发送建议通知按钮
                Button(action: {
                    sendSuggestionTest()
                }) {
                    HStack {
                        Image(systemName: "lightbulb.fill")
                            .foregroundColor(PetUtils.getElementDialogColor(for: profileManager.userProfile.fiveElements?.primary ?? "金"))
                            .font(.title2)
                        
                        VStack(alignment: .leading, spacing: 4) {
                            Text("发送建议通知")
                                .font(.headline)
                                .fontWeight(.semibold)
                                .foregroundColor(PetUtils.getElementTextColor(for: profileManager.userProfile.fiveElements?.primary ?? "金"))
                            
                            Text("随机选择一个建议进行推送")
                                .font(.caption)
                                .foregroundColor(PetUtils.getElementTextColor(for: profileManager.userProfile.fiveElements?.primary ?? "金").opacity(0.7))
                        }
                        
                        Spacer()
                        
                        Image(systemName: "chevron.right")
                            .foregroundColor(PetUtils.getElementTextColor(for: profileManager.userProfile.fiveElements?.primary ?? "金").opacity(0.7))
                            .font(.caption)
                    }
                    .padding()
                    .background(
                        RoundedRectangle(cornerRadius: 16)
                            .fill(PetUtils.getElementDialogColor(for: profileManager.userProfile.fiveElements?.primary ?? "金").opacity(0.2))
                            .overlay(
                                RoundedRectangle(cornerRadius: 16)
                                    .stroke(PetUtils.getElementDialogColor(for: profileManager.userProfile.fiveElements?.primary ?? "金").opacity(0.5), lineWidth: 1)
                            )
                    )
                }
                .buttonStyle(PlainButtonStyle())
                
                // 发送完成通知按钮
                Button(action: {
                    sendCompletionTest()
                }) {
                    HStack {
                        Image(systemName: "checkmark.circle.fill")
                            .foregroundColor(PetUtils.getElementDialogColor(for: profileManager.userProfile.fiveElements?.primary ?? "金"))
                            .font(.title2)
                        
                        VStack(alignment: .leading, spacing: 4) {
                            Text("发送完成通知")
                                .font(.headline)
                                .fontWeight(.semibold)
                                .foregroundColor(PetUtils.getElementTextColor(for: profileManager.userProfile.fiveElements?.primary ?? "金"))
                            
                            Text("发送完成通知并增加亲密度")
                                .font(.caption)
                                .foregroundColor(PetUtils.getElementTextColor(for: profileManager.userProfile.fiveElements?.primary ?? "金").opacity(0.7))
                        }
                        
                        Spacer()
                        
                        Image(systemName: "chevron.right")
                            .foregroundColor(PetUtils.getElementTextColor(for: profileManager.userProfile.fiveElements?.primary ?? "金").opacity(0.7))
                            .font(.caption)
                    }
                    .padding()
                    .background(
                        RoundedRectangle(cornerRadius: 16)
                            .fill(PetUtils.getElementDialogColor(for: profileManager.userProfile.fiveElements?.primary ?? "金").opacity(0.2))
                            .overlay(
                                RoundedRectangle(cornerRadius: 16)
                                    .stroke(PetUtils.getElementDialogColor(for: profileManager.userProfile.fiveElements?.primary ?? "金").opacity(0.5), lineWidth: 1)
                            )
                    )
                }
                .buttonStyle(PlainButtonStyle())
            }
        }
    }
    
    // MARK: - 设置卡片
    private var settingsSection: some View {
        NavigationLink(destination: SettingsView()) {
            HStack {
                Image(systemName: "gearshape.fill")
                    .foregroundColor(PetUtils.getElementDialogColor(for: profileManager.userProfile.fiveElements?.primary ?? "金"))
                    .font(.title2)
                
                VStack(alignment: .leading, spacing: 4) {
                    Text("设置与数据")
                        .font(.headline)
                        .fontWeight(.semibold)
                        .foregroundColor(PetUtils.getElementTextColor(for: profileManager.userProfile.fiveElements?.primary ?? "金"))
                    
                    Text("查看所有数据并更改设置")
                        .font(.caption)
                        .foregroundColor(PetUtils.getElementTextColor(for: profileManager.userProfile.fiveElements?.primary ?? "金").opacity(0.7))
                }
                
                Spacer()
                
                Image(systemName: "chevron.right")
                    .foregroundColor(PetUtils.getElementTextColor(for: profileManager.userProfile.fiveElements?.primary ?? "金").opacity(0.7))
                    .font(.caption)
            }
            .padding()
            .background(
                RoundedRectangle(cornerRadius: 16)
                    .fill(Color.gray.opacity(0.2))
                    .overlay(
                        RoundedRectangle(cornerRadius: 16)
                            .stroke(PetUtils.getElementDialogColor(for: profileManager.userProfile.fiveElements?.primary ?? "金").opacity(0.5), lineWidth: 1)
                    )
            )
        }
        .buttonStyle(PlainButtonStyle())
    }
    
    // MARK: - 获取健康数据
    private func getHealthData(for type: HealthReminder.ReminderType) -> String {
        switch type {
        case .sunExposure:
            return "紫外线: \(environmentManager.getUVStatus())"
        case .stress:
            let hrv = Int(healthKitManager.heartRateVariability)
            return hrv > 0 ? "\(hrv)ms" : "暂无数据"
        case .sedentary:
            return "\(healthKitManager.steps) 步"
        case .exercise:
            let hr = healthKitManager.heartRate
            return hr > 0 ? "\(hr) BPM" : "暂无数据"
        case .sleep:
            return healthKitManager.sleepAnalysis
        }
    }
    
    // MARK: - 发送建议通知
    private func sendSuggestionTest() {
        let userElement = profileManager.userProfile.fiveElements?.primary ?? "金"
        let delay = isDelayedNotification ? 10.0 : 1.0
        
        print("发送建议通知 - 用户元素: \(userElement), 延迟: \(delay)秒")
        
        systemNotificationManager.sendRandomSuggestionNotification(
            for: userElement,
            delay: delay
        )
    }
    
    // MARK: - 发送完成通知
    private func sendCompletionTest() {
        let userElement = profileManager.userProfile.fiveElements?.primary ?? "金"
        let delay = isDelayedNotification ? 10.0 : 1.0
        
        print("发送完成通知 - 用户元素: \(userElement), 延迟: \(delay)秒")
        
        systemNotificationManager.sendRandomCompletionNotification(
            for: userElement,
            delay: delay
        )
    }
}

// MARK: - 预览
struct HealthDashboardPageView_Previews: PreviewProvider {
    static var previews: some View {
        HealthDashboardPageView()
    }
} 

----

----
FilePath: ming-ling-watch-os Watch App/Views/HealthDetailView.swift
Lines: 452
import SwiftUI
import HealthKit

struct HealthDetailView: View {
    let reminder: HealthReminder
    let userElement: String
    @StateObject private var healthKitManager = HealthKitManager.shared
    @State private var todayRecords: [HealthRecord] = []
    @State private var weeklyData: [DailyHealthData] = []
    @State private var isLoading = true
    
    // 从主页面传递健康数据
    let healthData: String
    
    var body: some View {
        ScrollView {
            VStack(spacing: 20) {
                // 标题和当前状态
                headerSection
                
                // 今日数据概览
                todayOverviewSection
                
                // 今日触发记录
                todayRecordsSection
                
                // 最近7天数据
                weeklyDataSection
            }
            .padding()
        }
        .background(PetUtils.getElementBackgroundColor(for: userElement))
        .navigationTitle(reminder.title)
        .navigationBarTitleDisplayMode(.inline)
        .onAppear {
            loadData()
        }
    }
    
    // MARK: - 标题和当前状态
    private var headerSection: some View {
        VStack(spacing: 12) {
            HStack {
                Image(systemName: reminder.icon)
                    .font(.title)
                    .foregroundColor(PetUtils.getElementDialogColor(for: userElement))
                
                VStack(alignment: .leading, spacing: 4) {
                    Text(reminder.title)
                        .font(.headline)
                        .fontWeight(.semibold)
                        .foregroundColor(PetUtils.getElementTextColor(for: userElement))
                    
                    Text(reminder.description)
                        .font(.caption)
                        .foregroundColor(PetUtils.getElementTextColor(for: userElement).opacity(0.7))
                }
                
                Spacer()
            }
            
            // 当前状态指示器
            HStack {
                Circle()
                    .fill(getStatusColor())
                    .frame(width: 12, height: 12)
                
                Text(getStatusText())
                    .font(.caption)
                    .foregroundColor(PetUtils.getElementTextColor(for: userElement))
                
                Spacer()
            }
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: 16)
                .fill(PetUtils.getElementDialogColor(for: userElement).opacity(0.2))
                .overlay(
                    RoundedRectangle(cornerRadius: 16)
                        .stroke(PetUtils.getElementDialogColor(for: userElement).opacity(0.5), lineWidth: 1)
                )
        )
    }
    
    // MARK: - 今日数据概览
    private var todayOverviewSection: some View {
        VStack(spacing: 16) {
            Text("今日数据")
                .font(.headline)
                .fontWeight(.semibold)
                .frame(maxWidth: .infinity, alignment: .leading)
                .foregroundColor(PetUtils.getElementTextColor(for: userElement))
            
            HStack(spacing: 16) {
                // 当前值
                VStack(spacing: 8) {
                    Text(getCurrentValue())
                        .font(.title2)
                        .fontWeight(.bold)
                        .foregroundColor(PetUtils.getElementTextColor(for: userElement))
                    
                    Text("当前值")
                        .font(.caption)
                        .foregroundColor(PetUtils.getElementTextColor(for: userElement).opacity(0.7))
                }
                .frame(maxWidth: .infinity)
                .padding()
                .background(
                    RoundedRectangle(cornerRadius: 12)
                        .fill(PetUtils.getElementDialogColor(for: userElement).opacity(0.1))
                )
                
                // 目标值
                VStack(spacing: 8) {
                    Text(getTargetValue())
                        .font(.title2)
                        .fontWeight(.bold)
                        .foregroundColor(PetUtils.getElementTextColor(for: userElement))
                    
                    Text("目标值")
                        .font(.caption)
                        .foregroundColor(PetUtils.getElementTextColor(for: userElement).opacity(0.7))
                }
                .frame(maxWidth: .infinity)
                .padding()
                .background(
                    RoundedRectangle(cornerRadius: 12)
                        .fill(PetUtils.getElementDialogColor(for: userElement).opacity(0.1))
                )
            }
        }
    }
    
    // MARK: - 今日触发记录
    private var todayRecordsSection: some View {
        VStack(spacing: 16) {
            Text("今日触发记录")
                .font(.headline)
                .fontWeight(.semibold)
                .frame(maxWidth: .infinity, alignment: .leading)
                .foregroundColor(PetUtils.getElementTextColor(for: userElement))
            
            if todayRecords.isEmpty {
                Text("暂无触发记录")
                    .font(.caption)
                    .foregroundColor(PetUtils.getElementTextColor(for: userElement).opacity(0.7))
                    .frame(maxWidth: .infinity)
                    .padding()
                    .background(
                        RoundedRectangle(cornerRadius: 12)
                            .fill(PetUtils.getElementDialogColor(for: userElement).opacity(0.1))
                    )
            } else {
                LazyVStack(spacing: 8) {
                    ForEach(todayRecords, id: \.id) { record in
                        HealthRecordRow(record: record, userElement: userElement)
                    }
                }
            }
        }
    }
    
    // MARK: - 最近7天数据
    private var weeklyDataSection: some View {
        VStack(spacing: 16) {
            Text("最近7天")
                .font(.headline)
                .fontWeight(.semibold)
                .frame(maxWidth: .infinity, alignment: .leading)
                .foregroundColor(PetUtils.getElementTextColor(for: userElement))
            
            LazyVStack(spacing: 8) {
                ForEach(weeklyData, id: \.date) { data in
                    WeeklyDataRow(data: data, userElement: userElement)
                }
            }
        }
    }
    
    // MARK: - 获取当前值
    private func getCurrentValue() -> String {
        // 优先使用从主页面传递的数据，如果没有则从HealthKitManager获取
        if healthData != "暂无数据" && !healthData.isEmpty {
            return healthData
        }
        
        // 从HealthKitManager获取最新数据
        switch reminder.type {
        case .sunExposure:
            return "紫外线: \(EnvironmentSensorManager.shared.getUVStatus())"
        case .stress:
            let hrv = Int(healthKitManager.heartRateVariability)
            return hrv > 0 ? "\(hrv)ms" : "暂无数据"
        case .sedentary:
            return "\(healthKitManager.steps) 步"
        case .exercise:
            let hr = healthKitManager.heartRate
            return hr > 0 ? "\(hr) BPM" : "暂无数据"
        case .sleep:
            return healthKitManager.sleepAnalysis
        }
    }
    
    // MARK: - 获取目标值
    private func getTargetValue() -> String {
        switch reminder.type {
        case .sunExposure:
            return "15-30分钟"
        case .stress:
            return "< 50ms"
        case .sedentary:
            return "10,000步"
        case .exercise:
            return "120-180 BPM"
        case .sleep:
            return "7-9小时"
        }
    }
    
    // MARK: - 获取状态颜色
    private func getStatusColor() -> Color {
        // 这里可以根据实际数据判断状态
        return .green
    }
    
    // MARK: - 获取状态文本
    private func getStatusText() -> String {
        // 这里可以根据实际数据判断状态
        return "状态良好"
    }
    
    // MARK: - 加载数据
    private func loadData() {
        isLoading = true
        
        // 模拟加载今日记录
        DispatchQueue.main.asyncAfter(deadline: .now() + 1) {
            self.todayRecords = self.generateMockRecords()
            self.weeklyData = self.generateMockWeeklyData()
            self.isLoading = false
        }
    }
    
    // MARK: - 生成模拟记录
    private func generateMockRecords() -> [HealthRecord] {
        let now = Date()
        let calendar = Calendar.current
        
        return [
            HealthRecord(
                id: UUID(),
                timestamp: calendar.date(byAdding: .hour, value: -2, to: now) ?? now,
                value: healthData,
                status: .completed,
                description: "完成目标"
            ),
            HealthRecord(
                id: UUID(),
                timestamp: calendar.date(byAdding: .hour, value: -4, to: now) ?? now,
                value: healthData,
                status: .triggered,
                description: "触发提醒"
            )
        ]
    }
    
    // MARK: - 生成模拟周数据
    private func generateMockWeeklyData() -> [DailyHealthData] {
        let calendar = Calendar.current
        let now = Date()
        
        return (0..<7).map { dayOffset in
            let date = calendar.date(byAdding: .day, value: -dayOffset, to: now) ?? now
            return DailyHealthData(
                date: date,
                value: healthData,
                isCompleted: Bool.random(),
                triggerCount: Int.random(in: 0...3)
            )
        }.reversed()
    }
}

// MARK: - 健康记录模型
struct HealthRecord: Identifiable {
    let id: UUID
    let timestamp: Date
    let value: String
    let status: RecordStatus
    let description: String
    
    enum RecordStatus {
        case completed
        case triggered
        case warning
    }
}

// MARK: - 每日健康数据模型
struct DailyHealthData: Identifiable {
    let id = UUID()
    let date: Date
    let value: String
    let isCompleted: Bool
    let triggerCount: Int
}

// MARK: - 健康记录行视图
struct HealthRecordRow: View {
    let record: HealthRecord
    let userElement: String
    
    var body: some View {
        HStack(spacing: 12) {
            // 状态图标
            Image(systemName: getStatusIcon())
                .font(.title3)
                .foregroundColor(getStatusColor())
            
            VStack(alignment: .leading, spacing: 4) {
                Text(record.description)
                    .font(.headline)
                    .fontWeight(.semibold)
                    .foregroundColor(PetUtils.getElementTextColor(for: userElement))
                
                Text(record.value)
                    .font(.caption)
                    .foregroundColor(PetUtils.getElementTextColor(for: userElement).opacity(0.7))
            }
            
            Spacer()
            
            Text(formatTime(record.timestamp))
                .font(.caption)
                .foregroundColor(PetUtils.getElementTextColor(for: userElement).opacity(0.7))
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(PetUtils.getElementDialogColor(for: userElement).opacity(0.1))
        )
    }
    
    private func getStatusIcon() -> String {
        switch record.status {
        case .completed:
            return "checkmark.circle.fill"
        case .triggered:
            return "exclamationmark.circle.fill"
        case .warning:
            return "exclamationmark.triangle.fill"
        }
    }
    
    private func getStatusColor() -> Color {
        switch record.status {
        case .completed:
            return .green
        case .triggered:
            return .orange
        case .warning:
            return .red
        }
    }
    
    private func formatTime(_ date: Date) -> String {
        let formatter = DateFormatter()
        formatter.timeStyle = .short
        return formatter.string(from: date)
    }
}

// MARK: - 周数据行视图
struct WeeklyDataRow: View {
    let data: DailyHealthData
    let userElement: String
    
    var body: some View {
        HStack(spacing: 12) {
            // 日期
            VStack(spacing: 4) {
                Text(formatDay(data.date))
                    .font(.headline)
                    .fontWeight(.semibold)
                    .foregroundColor(PetUtils.getElementTextColor(for: userElement))
                
                Text(formatDate(data.date))
                    .font(.caption)
                    .foregroundColor(PetUtils.getElementTextColor(for: userElement).opacity(0.7))
            }
            .frame(width: 60)
            
            // 数据值
            Text(data.value)
                .font(.headline)
                .fontWeight(.semibold)
                .foregroundColor(PetUtils.getElementTextColor(for: userElement))
            
            Spacer()
            
            // 状态指示器
            HStack(spacing: 8) {
                if data.isCompleted {
                    Image(systemName: "checkmark.circle.fill")
                        .foregroundColor(.green)
                        .font(.caption)
                }
                
                if data.triggerCount > 0 {
                    HStack(spacing: 2) {
                        Image(systemName: "bell.fill")
                            .foregroundColor(.orange)
                            .font(.caption)
                        
                        Text("\(data.triggerCount)")
                            .font(.caption)
                            .foregroundColor(.orange)
                    }
                }
            }
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(PetUtils.getElementDialogColor(for: userElement).opacity(0.1))
        )
    }
    
    private func formatDay(_ date: Date) -> String {
        let formatter = DateFormatter()
        formatter.dateFormat = "MM/dd"
        return formatter.string(from: date)
    }
    
    private func formatDate(_ date: Date) -> String {
        let formatter = DateFormatter()
        formatter.dateFormat = "E"
        return formatter.string(from: date)
    }
}

// MARK: - 预览
struct HealthDetailView_Previews: PreviewProvider {
    static var previews: some View {
        HealthDetailView(
            reminder: HealthReminder.allReminders[0],
            userElement: "金",
            healthData: "测试数据"
        )
    }
} 
----

----
FilePath: ming-ling-watch-os Watch App/Views/IntimacyChangeView.swift
Lines: 82
import SwiftUI

// MARK: - 亲密值变化通知视图
struct IntimacyChangeView: View {
    let points: Int
    let isPositive: Bool
    @State private var isVisible = false
    
    var body: some View {
        HStack(spacing: 8) {
            Image(systemName: isPositive ? "heart.fill" : "heart.slash")
                .foregroundColor(isPositive ? .red : .gray)
                .font(.caption)
            
            Text(isPositive ? "+\(points)" : "\(points)")
                .font(.caption)
                .fontWeight(.semibold)
                .foregroundColor(isPositive ? .red : .gray)
        }
        .padding(.horizontal, 8)
        .padding(.vertical, 4)
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(isPositive ? Color.red.opacity(0.1) : Color.gray.opacity(0.1))
                .overlay(
                    RoundedRectangle(cornerRadius: 12)
                        .stroke(isPositive ? Color.red.opacity(0.3) : Color.gray.opacity(0.3), lineWidth: 1)
                )
        )
        .opacity(isVisible ? 1 : 0)
        .scaleEffect(isVisible ? 1 : 0.8)
        .onAppear {
            withAnimation(.easeInOut(duration: 0.3)) {
                isVisible = true
            }
            
            // 3秒后自动隐藏
            DispatchQueue.main.asyncAfter(deadline: .now() + 3) {
                withAnimation(.easeInOut(duration: 0.3)) {
                    isVisible = false
                }
            }
        }
    }
}

// MARK: - 亲密值变化管理器
class IntimacyChangeManager: ObservableObject {
    static let shared = IntimacyChangeManager()
    
    @Published var currentChange: IntimacyChange?
    
    private init() {}
    
    func showChange(points: Int, isPositive: Bool) {
        currentChange = IntimacyChange(points: points, isPositive: isPositive)
        
        // 3秒后清除
        DispatchQueue.main.asyncAfter(deadline: .now() + 3) {
            self.currentChange = nil
        }
    }
}

// MARK: - 亲密值变化模型
struct IntimacyChange: Identifiable {
    let id = UUID()
    let points: Int
    let isPositive: Bool
    let timestamp = Date()
}

// MARK: - 预览
struct IntimacyChangeView_Previews: PreviewProvider {
    static var previews: some View {
        VStack(spacing: 20) {
            IntimacyChangeView(points: 10, isPositive: true)
            IntimacyChangeView(points: 5, isPositive: false)
        }
        .padding()
    }
} 
----

----
FilePath: ming-ling-watch-os Watch App/Views/MainPetView.swift
Lines: 39
import SwiftUI

// MARK: - 主宠物页面
struct MainPetView: View {
    @StateObject private var profileManager = UserProfileManager.shared
    @State private var currentPage = 0
    
    private let pages = ["宠物", "健康"]
    
    var body: some View {
        TabView(selection: $currentPage) {
            // 宠物页面
            PetPageView(userElement: profileManager.userProfile.fiveElements?.primary ?? "金")
                .tag(0)
            
            // 健康数据页面
            HealthDashboardPageView()
                .tag(1)
        }
        .tabViewStyle(PageTabViewStyle(indexDisplayMode: .automatic))
        .indexViewStyle(PageIndexViewStyle(backgroundDisplayMode: .automatic))
        .onAppear {
            profileManager.updateHealthStreak()
        }
    }
    

}





// MARK: - 预览
struct MainPetView_Previews: PreviewProvider {
    static var previews: some View {
        MainPetView()
    }
} 

----

----
FilePath: ming-ling-watch-os Watch App/Views/PetAnimationView.swift
Lines: 192
import SwiftUI
import CoreMotion

// MARK: - 宠物动画视图
struct PetAnimationView: View {
    let userElement: String
    @State private var currentEmoji = "🐱"
    @State private var isAnimating = false
    @State private var animationScale: CGFloat = 1.0
    @State private var animationRotation: Double = 0.0
    @State private var showHeart = false
    @State private var heartOffset: CGFloat = 0
    
    private let motionManager = CMMotionManager()
    
    var body: some View {
        ZStack {
            // 背景
            Color.clear
            
            // 宠物表情
            Text(currentEmoji)
                .font(.system(size: 80))
                .scaleEffect(animationScale)
                .rotationEffect(.degrees(animationRotation))
                .animation(.easeInOut(duration: 0.3), value: animationScale)
                .animation(.easeInOut(duration: 0.5), value: animationRotation)
                .onTapGesture {
                    petThePet()
                }
                .gesture(
                    DragGesture(minimumDistance: 0)
                        .onChanged { _ in
                            if !isAnimating {
                                petThePet()
                            }
                        }
                )
            
            // 爱心效果
            if showHeart {
                Text("❤️")
                    .font(.system(size: 30))
                    .offset(y: heartOffset)
                    .opacity(showHeart ? 1 : 0)
                    .animation(.easeOut(duration: 1.0), value: heartOffset)
                    .animation(.easeOut(duration: 1.0), value: showHeart)
            }
        }
        .onAppear {
            setupPet()
            startMotionDetection()
        }
        .onDisappear {
            stopMotionDetection()
        }
    }
    
    // MARK: - 设置宠物
    private func setupPet() {
        switch userElement {
        case "金":
            currentEmoji = "🐯"
        case "木":
            currentEmoji = "🐱"
        case "水":
            currentEmoji = "🐬"
        case "火":
            currentEmoji = "🦁"
        case "土":
            currentEmoji = "🐮"
        default:
            currentEmoji = "🐱"
        }
    }
    
    // MARK: - 抚摸宠物
    private func petThePet() {
        guard !isAnimating else { return }
        
        isAnimating = true
        
        // 缩放动画
        withAnimation(.easeInOut(duration: 0.2)) {
            animationScale = 1.2
        }
        
        // 旋转动画
        withAnimation(.easeInOut(duration: 0.3)) {
            animationRotation = 10
        }
        
        // 显示爱心
        showHeart = true
        heartOffset = -50
        
        // 重置动画
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) {
            withAnimation(.easeInOut(duration: 0.2)) {
                animationScale = 1.0
                animationRotation = 0
            }
        }
        
        // 隐藏爱心
        DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {
            showHeart = false
            heartOffset = 0
        }
        
        // 重置状态
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
            isAnimating = false
        }
    }
    
    // MARK: - 摇一摇动画
    private func shakeThePet() {
        guard !isAnimating else { return }
        
        isAnimating = true
        
        // 剧烈摇晃动画
        withAnimation(.easeInOut(duration: 0.1).repeatCount(5, autoreverses: true)) {
            animationRotation = 15
        }
        
        // 缩放动画
        withAnimation(.easeInOut(duration: 0.2)) {
            animationScale = 1.3
        }
        
        // 切换表情
        let shakeEmojis = ["😵", "😱", "😨", "😰"]
        let randomEmoji = shakeEmojis.randomElement() ?? "😵"
        
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) {
            currentEmoji = randomEmoji
        }
        
        // 重置动画
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
            withAnimation(.easeInOut(duration: 0.2)) {
                animationScale = 1.0
                animationRotation = 0
            }
        }
        
        // 恢复原表情
        DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {
            setupPet()
        }
        
        // 重置状态
        DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {
            isAnimating = false
        }
    }
    
    // MARK: - 开始运动检测
    private func startMotionDetection() {
        guard motionManager.isAccelerometerAvailable else { return }
        
        motionManager.accelerometerUpdateInterval = 0.1
        motionManager.startAccelerometerUpdates(to: .main) { data, error in
            guard let data = data else { return }
            
            let acceleration = sqrt(
                data.acceleration.x * data.acceleration.x +
                data.acceleration.y * data.acceleration.y +
                data.acceleration.z * data.acceleration.z
            )
            
            // 检测摇一摇（加速度大于2.0）
            if acceleration > 2.0 && !isAnimating {
                shakeThePet()
            }
        }
    }
    
    // MARK: - 停止运动检测
    private func stopMotionDetection() {
        motionManager.stopAccelerometerUpdates()
    }
}

// MARK: - 预览
struct PetAnimationView_Previews: PreviewProvider {
    static var previews: some View {
        PetAnimationView(userElement: "木")
    }
} 
----

----
FilePath: ming-ling-watch-os Watch App/Views/PetPageView.swift
Lines: 49
import SwiftUI

// MARK: - 宠物页面
struct PetPageView: View {
    let userElement: String
    @StateObject private var intimacyChangeManager = IntimacyChangeManager.shared
    
    var body: some View {
        ZStack {
            // 背景渐变
            LinearGradient(
                gradient: Gradient(colors: [
                    PetUtils.getElementBackgroundColor(for: userElement).opacity(0.3),
                    Color.black
                ]),
                startPoint: .topLeading,
                endPoint: .bottomTrailing
            )
            .ignoresSafeArea()
            
            // 宠物图片和亲密值通知
            VStack {
                Spacer()
                
                Image(PetUtils.getPetImageName(for: userElement))
                    .resizable()
                    .aspectRatio(contentMode: .fit)
                    .frame(maxWidth: 200, maxHeight: 200)
                    .scaleEffect(1.0)
                    .animation(.easeInOut(duration: 0.5), value: PetUtils.getPetImageName(for: userElement))
                
                // 亲密值变化通知
                if let change = intimacyChangeManager.currentChange {
                    IntimacyChangeView(points: change.points, isPositive: change.isPositive)
                        .transition(.opacity.combined(with: .scale))
                }
                
                Spacer()
            }
        }
    }
}

// MARK: - 预览
struct PetPageView_Previews: PreviewProvider {
    static var previews: some View {
        PetPageView(userElement: "金")
    }
} 
----

----
FilePath: ming-ling-watch-os Watch App/Views/SettingsView.swift
Lines: 385
import SwiftUI

struct SettingsView: View {
    @StateObject private var profileManager = UserProfileManager.shared
    @StateObject private var healthKitManager = HealthKitManager.shared
    @Environment(\.dismiss) private var dismiss
    @State private var showingBirthdaySelection = false
    @State private var showingResetAlert = false
    
    var body: some View {
        NavigationView {
            ScrollView {
                VStack(spacing: 20) {
                    // 用户信息卡片
                    userInfoCard
                    
                    // 亲密值卡片
                    intimacyCard
                    
                    // 设置选项
                    settingsOptions
                    
                    Spacer(minLength: 20)
                }
                .padding(.horizontal)
            }
            .navigationTitle("设置")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .primaryAction) {
                    Button("完成") {
                        dismiss()
                    }
                }
            }
        }
        .sheet(isPresented: $showingBirthdaySelection) {
            BirthdaySelectionView()
        }
        .alert("重置档案", isPresented: $showingResetAlert) {
            Button("取消", role: .cancel) { }
            Button("重置", role: .destructive) {
                profileManager.resetProfile()
                dismiss()
            }
        } message: {
            Text("这将重置所有数据和设置。您确定吗？")
        }
    }
    
    // MARK: - 用户信息卡片
    private var userInfoCard: some View {
        VStack(spacing: 16) {
            // 头像和基本信息
            HStack(spacing: 16) {
                Circle()
                    .fill(profileManager.getThemeColor())
                    .frame(width: 60, height: 60)
                    .overlay(
                        Image(systemName: "heart.fill")
                            .foregroundColor(.white)
                            .font(.title2)
                    )
                
                VStack(alignment: .leading, spacing: 4) {
                    if let petName = profileManager.userProfile.petRecommendation {
                        Text(petName)
                            .font(.title2)
                            .fontWeight(.bold)
                            .foregroundColor(profileManager.getThemeColor())
                    }
                    
                    if let element = profileManager.userProfile.fiveElements {
                        Text(element.primary + " 体质")
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                    
                    Text("健康坚持: \(profileManager.userProfile.healthStreak) 天")
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
                
                Spacer()
            }
            
            // 生日信息
            if let birthday = profileManager.userProfile.birthday {
                HStack {
                    Image(systemName: "calendar")
                        .foregroundColor(.blue)
                    
                    Text("生日: \(formatDate(birthday))")
                        .font(.caption)
                        .foregroundColor(.secondary)
                    
                    Spacer()
                    
                    Button("更改") {
                        showingBirthdaySelection = true
                    }
                    .font(.caption)
                    .foregroundColor(.blue)
                }
                .padding(.horizontal)
                .padding(.vertical, 8)
                .background(
                    RoundedRectangle(cornerRadius: 8)
                        .fill(Color.blue.opacity(0.1))
                )
            }
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: 16)
                .fill(Color.gray.opacity(0.1))
                .overlay(
                    RoundedRectangle(cornerRadius: 16)
                        .stroke(profileManager.getThemeColor().opacity(0.3), lineWidth: 1)
                )
        )
    }
    
    // MARK: - 亲密值卡片
    private var intimacyCard: some View {
        VStack(spacing: 16) {
            Text("亲密值")
                .font(.headline)
                .fontWeight(.semibold)
                .frame(maxWidth: .infinity, alignment: .leading)
            
            // 亲密值等级和进度
            VStack(spacing: 12) {
                HStack {
                    Image(systemName: profileManager.userProfile.intimacyGradeIcon)
                        .foregroundColor(Color(hex: profileManager.userProfile.intimacyGradeColor))
                        .font(.title2)
                    
                    VStack(alignment: .leading, spacing: 2) {
                        Text(profileManager.userProfile.intimacyGradeName)
                            .font(.headline)
                            .fontWeight(.semibold)
                        
                        Text("等级 \(profileManager.userProfile.intimacyGrade)")
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                    
                    Spacer()
                    
                    VStack(alignment: .trailing, spacing: 2) {
                        Text("\(profileManager.userProfile.intimacyLevel)")
                            .font(.title2)
                            .fontWeight(.bold)
                            .foregroundColor(Color(hex: profileManager.userProfile.intimacyGradeColor))
                        
                        Text("积分")
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                }
                
                // 进度条
                VStack(spacing: 4) {
                    ProgressView(value: profileManager.userProfile.intimacyProgress)
                        .progressViewStyle(LinearProgressViewStyle(tint: Color(hex: profileManager.userProfile.intimacyGradeColor)))
                    
                    HStack {
                        Text("0")
                            .font(.caption2)
                            .foregroundColor(.secondary)
                        
                        Spacer()
                        
                        if profileManager.userProfile.pointsToNextGrade > 0 {
                            Text("距离下一等级还需 \(profileManager.userProfile.pointsToNextGrade) 积分")
                                .font(.caption2)
                                .foregroundColor(.secondary)
                        } else {
                            Text("已达到最高等级")
                                .font(.caption2)
                                .foregroundColor(.green)
                        }
                        
                        Spacer()
                        
                        Text("100")
                            .font(.caption2)
                            .foregroundColor(.secondary)
                    }
                }
            }
            
            // 测试按钮
            VStack(spacing: 8) {
                Text("测试功能")
                    .font(.subheadline)
                    .fontWeight(.medium)
                    .frame(maxWidth: .infinity, alignment: .leading)
                
                HStack(spacing: 12) {
                    Button(action: {
                        profileManager.addIntimacy(10)
                    }) {
                        HStack {
                            Image(systemName: "plus.circle.fill")
                                .foregroundColor(.green)
                            Text("+10")
                                .fontWeight(.semibold)
                        }
                        .frame(maxWidth: .infinity)
                        .padding(.vertical, 8)
                        .background(
                            RoundedRectangle(cornerRadius: 8)
                                .fill(Color.green.opacity(0.1))
                                .overlay(
                                    RoundedRectangle(cornerRadius: 8)
                                        .stroke(Color.green.opacity(0.3), lineWidth: 1)
                                )
                        )
                    }
                    .buttonStyle(PlainButtonStyle())
                    
                    Button(action: {
                        profileManager.reduceIntimacy(10)
                    }) {
                        HStack {
                            Image(systemName: "minus.circle.fill")
                                .foregroundColor(.red)
                            Text("-10")
                                .fontWeight(.semibold)
                        }
                        .frame(maxWidth: .infinity)
                        .padding(.vertical, 8)
                        .background(
                            RoundedRectangle(cornerRadius: 8)
                                .fill(Color.red.opacity(0.1))
                                .overlay(
                                    RoundedRectangle(cornerRadius: 8)
                                        .stroke(Color.red.opacity(0.3), lineWidth: 1)
                                )
                        )
                    }
                    .buttonStyle(PlainButtonStyle())
                }
            }
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: 16)
                .fill(Color.gray.opacity(0.1))
                .overlay(
                    RoundedRectangle(cornerRadius: 16)
                        .stroke(Color(hex: profileManager.userProfile.intimacyGradeColor).opacity(0.3), lineWidth: 1)
                )
        )
    }
    

    
    // MARK: - 设置选项
    private var settingsOptions: some View {
        VStack(spacing: 12) {
            Text("设置")
                .font(.headline)
                .fontWeight(.semibold)
                .frame(maxWidth: .infinity, alignment: .leading)
            
            VStack(spacing: 8) {
                // 重新选择生日
                Button(action: {
                    showingBirthdaySelection = true
                }) {
                    SettingsRowView(
                        icon: "calendar.badge.plus",
                        title: "更改生日",
                        subtitle: "重新计算您的体质",
                        color: .blue
                    )
                }
                .buttonStyle(PlainButtonStyle())
                
                // 通知设置
                Button(action: {
                    // 通知设置逻辑
                }) {
                    SettingsRowView(
                        icon: "bell.fill",
                        title: "通知",
                        subtitle: "管理健康提醒",
                        color: .orange
                    )
                }
                .buttonStyle(PlainButtonStyle())
                
                // 八字详情
                if let baziData = profileManager.userProfile.baziData {
                    NavigationLink(destination: BaziDetailView(baziData: baziData, userElement: profileManager.userProfile.fiveElements?.primary ?? "金")) {
                        SettingsRowView(
                            icon: "sparkles",
                            title: "八字分析",
                            subtitle: "查看您的生辰八字详情",
                            color: .purple
                        )
                    }
                    .buttonStyle(PlainButtonStyle())
                }
                
                // 数据导出
                Button(action: {
                    // 数据导出逻辑
                }) {
                    SettingsRowView(
                        icon: "square.and.arrow.up",
                        title: "导出数据",
                        subtitle: "下载您的健康数据",
                        color: .green
                    )
                }
                .buttonStyle(PlainButtonStyle())
                
                // 重置数据
                Button(action: {
                    showingResetAlert = true
                }) {
                    SettingsRowView(
                        icon: "trash.fill",
                        title: "重置所有数据",
                        subtitle: "清除所有设置和数据",
                        color: .red
                    )
                }
                .buttonStyle(PlainButtonStyle())
            }
        }
    }
    
    // MARK: - 格式化日期
    private func formatDate(_ date: Date) -> String {
        let formatter = DateFormatter()
        formatter.dateStyle = .medium
        return formatter.string(from: date)
    }
}



// MARK: - 设置行视图
struct SettingsRowView: View {
    let icon: String
    let title: String
    let subtitle: String
    let color: Color
    
    var body: some View {
        HStack(spacing: 12) {
            Image(systemName: icon)
                .font(.title3)
                .foregroundColor(color)
                .frame(width: 24)
            
            VStack(alignment: .leading, spacing: 2) {
                Text(title)
                    .font(.headline)
                    .fontWeight(.semibold)
                    .foregroundColor(.primary)
                
                Text(subtitle)
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
            
            Spacer()
            
            Image(systemName: "chevron.right")
                .foregroundColor(.secondary)
                .font(.caption)
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(Color.gray.opacity(0.1))
        )
    }
} 
----

----
FilePath: ming-ling-watch-os Watch App/ming-ling Watch App.entitlements
Lines: 8
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>com.apple.developer.healthkit</key>
	<true/>
</dict>
</plist>

----

----
FilePath: ming-ling-watch-os Watch App/ming-ling-watch-os Watch App.entitlements
Lines: 8
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>com.apple.developer.healthkit</key>
	<true/>
</dict>
</plist>

----

----
FilePath: ming-ling-watch-os Watch App/ming_ling_watch_osApp.swift
Lines: 38
//
//  ming_ling_watch_osApp.swift
//  ming-ling-watch-os Watch App
//
//  Created by CreepOnSky on 2025/7/24.
//

import SwiftUI
import WatchKit

@main
struct ming_ling_watch_os_Watch_AppApp: App {
    @StateObject private var profileManager = UserProfileManager.shared
    @StateObject private var monitoringService = HealthMonitoringService.shared
    @WKApplicationDelegateAdaptor var appDelegate: WatchOSAppDelegate
    
    var body: some Scene {
        WindowGroup {
            if profileManager.isProfileComplete {
                // 用户已完成档案设置，显示主界面
                NavigationView {
                    MainPetView()
                }
                .navigationViewStyle(StackNavigationViewStyle())
                .onAppear {
                    // 启动后台健康监测
                    monitoringService.startMonitoring()
                }
            } else {
                // 用户未完成档案设置，显示生日选择界面
                BirthdaySelectionView()
            }
        }
        
        // 配置自定义通知界面
        WKNotificationScene(controller: NotificationController.self, category: "PET_NOTIFICATION")
    }
}

----

----
FilePath: ming-ling-watch-os Watch AppTests/ming_ling_watch_os_Watch_AppTests.swift
Lines: 17
//
//  ming_ling_watch_os_Watch_AppTests.swift
//  ming-ling-watch-os Watch AppTests
//
//  Created by CreepOnSky on 2025/7/24.
//

import Testing
@testable import ming_ling_watch_os_Watch_App

struct ming_ling_watch_os_Watch_AppTests {

    @Test func example() async throws {
        // Write your test here and use APIs like `#expect(...)` to check expected conditions.
    }

}

----

----
FilePath: ming-ling-watch-os Watch AppUITests/ming_ling_watch_os_Watch_AppUITests.swift
Lines: 41
//
//  ming_ling_watch_os_Watch_AppUITests.swift
//  ming-ling-watch-os Watch AppUITests
//
//  Created by CreepOnSky on 2025/7/24.
//

import XCTest

final class ming_ling_watch_os_Watch_AppUITests: XCTestCase {

    override func setUpWithError() throws {
        // Put setup code here. This method is called before the invocation of each test method in the class.

        // In UI tests it is usually best to stop immediately when a failure occurs.
        continueAfterFailure = false

        // In UI tests it’s important to set the initial state - such as interface orientation - required for your tests before they run. The setUp method is a good place to do this.
    }

    override func tearDownWithError() throws {
        // Put teardown code here. This method is called after the invocation of each test method in the class.
    }

    @MainActor
    func testExample() throws {
        // UI tests must launch the application that they test.
        let app = XCUIApplication()
        app.launch()

        // Use XCTAssert and related functions to verify your tests produce the correct results.
    }

    @MainActor
    func testLaunchPerformance() throws {
        // This measures how long it takes to launch your application.
        measure(metrics: [XCTApplicationLaunchMetric()]) {
            XCUIApplication().launch()
        }
    }
}

----

----
FilePath: ming-ling-watch-os Watch AppUITests/ming_ling_watch_os_Watch_AppUITestsLaunchTests.swift
Lines: 33
//
//  ming_ling_watch_os_Watch_AppUITestsLaunchTests.swift
//  ming-ling-watch-os Watch AppUITests
//
//  Created by CreepOnSky on 2025/7/24.
//

import XCTest

final class ming_ling_watch_os_Watch_AppUITestsLaunchTests: XCTestCase {

    override class var runsForEachTargetApplicationUIConfiguration: Bool {
        true
    }

    override func setUpWithError() throws {
        continueAfterFailure = false
    }

    @MainActor
    func testLaunch() throws {
        let app = XCUIApplication()
        app.launch()

        // Insert steps here to perform after app launch but before taking a screenshot,
        // such as logging into a test account or navigating somewhere in the app

        let attachment = XCTAttachment(screenshot: app.screenshot())
        attachment.name = "Launch Screen"
        attachment.lifetime = .keepAlways
        add(attachment)
    }
}

----

----
FilePath: ming-ling-watch-os-Watch-App-Info.plist
Lines: 17
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key></key>
	<string></string>
	<key>UIBackgroundModes</key>
	<array>
		<string>location</string>
	</array>
	<key>WKBackgroundModes</key>
	<array>
		<string>self-care</string>
		<string>workout-processing</string>
	</array>
</dict>
</plist>

----

----
FilePath: ming-ling-watch-os.xcodeproj/project.pbxproj
Lines: 704
// !$*UTF8*$!
{
	archiveVersion = 1;
	classes = {
	};
	objectVersion = 77;
	objects = {

/* Begin PBXBuildFile section */
		3DB372E82E32739000A91180 /* ming-ling-watch-os Watch App.app in Embed Watch Content */ = {isa = PBXBuildFile; fileRef = 3DB372E72E32739000A91180 /* ming-ling-watch-os Watch App.app */; settings = {ATTRIBUTES = (RemoveHeadersOnCopy, ); }; };
/* End PBXBuildFile section */

/* Begin PBXContainerItemProxy section */
		3DB372E92E32739000A91180 /* PBXContainerItemProxy */ = {
			isa = PBXContainerItemProxy;
			containerPortal = 3DB372DB2E32738F00A91180 /* Project object */;
			proxyType = 1;
			remoteGlobalIDString = 3DB372E62E32739000A91180;
			remoteInfo = "ming-ling-watch-os Watch App";
		};
		3DB372F72E32739100A91180 /* PBXContainerItemProxy */ = {
			isa = PBXContainerItemProxy;
			containerPortal = 3DB372DB2E32738F00A91180 /* Project object */;
			proxyType = 1;
			remoteGlobalIDString = 3DB372E62E32739000A91180;
			remoteInfo = "ming-ling-watch-os Watch App";
		};
		3DB373012E32739100A91180 /* PBXContainerItemProxy */ = {
			isa = PBXContainerItemProxy;
			containerPortal = 3DB372DB2E32738F00A91180 /* Project object */;
			proxyType = 1;
			remoteGlobalIDString = 3DB372E62E32739000A91180;
			remoteInfo = "ming-ling-watch-os Watch App";
		};
/* End PBXContainerItemProxy section */

/* Begin PBXCopyFilesBuildPhase section */
		3D83DEFA2E3353B400609605 /* Embed Foundation Extensions */ = {
			isa = PBXCopyFilesBuildPhase;
			buildActionMask = 2147483647;
			dstPath = "";
			dstSubfolderSpec = 13;
			files = (
			);
			name = "Embed Foundation Extensions";
			runOnlyForDeploymentPostprocessing = 0;
		};
		3DB3730D2E32739100A91180 /* Embed Watch Content */ = {
			isa = PBXCopyFilesBuildPhase;
			buildActionMask = 2147483647;
			dstPath = "$(CONTENTS_FOLDER_PATH)/Watch";
			dstSubfolderSpec = 16;
			files = (
				3DB372E82E32739000A91180 /* ming-ling-watch-os Watch App.app in Embed Watch Content */,
			);
			name = "Embed Watch Content";
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXCopyFilesBuildPhase section */

/* Begin PBXFileReference section */
		3DB372E12E32739000A91180 /* ming-ling-watch-os.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = "ming-ling-watch-os.app"; sourceTree = BUILT_PRODUCTS_DIR; };
		3DB372E72E32739000A91180 /* ming-ling-watch-os Watch App.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = "ming-ling-watch-os Watch App.app"; sourceTree = BUILT_PRODUCTS_DIR; };
		3DB372F62E32739100A91180 /* ming-ling-watch-os Watch AppTests.xctest */ = {isa = PBXFileReference; explicitFileType = wrapper.cfbundle; includeInIndex = 0; path = "ming-ling-watch-os Watch AppTests.xctest"; sourceTree = BUILT_PRODUCTS_DIR; };
		3DB373002E32739100A91180 /* ming-ling-watch-os Watch AppUITests.xctest */ = {isa = PBXFileReference; explicitFileType = wrapper.cfbundle; includeInIndex = 0; path = "ming-ling-watch-os Watch AppUITests.xctest"; sourceTree = BUILT_PRODUCTS_DIR; };
/* End PBXFileReference section */

/* Begin PBXFileSystemSynchronizedRootGroup section */
		3D83DEEF2E3353B400609605 /* mingling-notifcation */ = {
			isa = PBXFileSystemSynchronizedRootGroup;
			path = "mingling-notifcation";
			sourceTree = "<group>";
		};
		3DB372EB2E32739000A91180 /* ming-ling-watch-os Watch App */ = {
			isa = PBXFileSystemSynchronizedRootGroup;
			path = "ming-ling-watch-os Watch App";
			sourceTree = "<group>";
		};
		3DB372F92E32739100A91180 /* ming-ling-watch-os Watch AppTests */ = {
			isa = PBXFileSystemSynchronizedRootGroup;
			path = "ming-ling-watch-os Watch AppTests";
			sourceTree = "<group>";
		};
		3DB373032E32739100A91180 /* ming-ling-watch-os Watch AppUITests */ = {
			isa = PBXFileSystemSynchronizedRootGroup;
			path = "ming-ling-watch-os Watch AppUITests";
			sourceTree = "<group>";
		};
/* End PBXFileSystemSynchronizedRootGroup section */

/* Begin PBXFrameworksBuildPhase section */
		3DB372E42E32739000A91180 /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		3DB372F32E32739100A91180 /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		3DB372FD2E32739100A91180 /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXFrameworksBuildPhase section */

/* Begin PBXGroup section */
		3DB372DA2E32738F00A91180 = {
			isa = PBXGroup;
			children = (
				3DB372EB2E32739000A91180 /* ming-ling-watch-os Watch App */,
				3DB372F92E32739100A91180 /* ming-ling-watch-os Watch AppTests */,
				3DB373032E32739100A91180 /* ming-ling-watch-os Watch AppUITests */,
				3D83DEEF2E3353B400609605 /* mingling-notifcation */,
				3DB372E22E32739000A91180 /* Products */,
			);
			sourceTree = "<group>";
		};
		3DB372E22E32739000A91180 /* Products */ = {
			isa = PBXGroup;
			children = (
				3DB372E12E32739000A91180 /* ming-ling-watch-os.app */,
				3DB372E72E32739000A91180 /* ming-ling-watch-os Watch App.app */,
				3DB372F62E32739100A91180 /* ming-ling-watch-os Watch AppTests.xctest */,
				3DB373002E32739100A91180 /* ming-ling-watch-os Watch AppUITests.xctest */,
			);
			name = Products;
			sourceTree = "<group>";
		};
/* End PBXGroup section */

/* Begin PBXNativeTarget section */
		3DB372E02E32739000A91180 /* ming-ling-watch-os */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = 3DB3730E2E32739100A91180 /* Build configuration list for PBXNativeTarget "ming-ling-watch-os" */;
			buildPhases = (
				3DB372DF2E32739000A91180 /* Resources */,
				3DB3730D2E32739100A91180 /* Embed Watch Content */,
			);
			buildRules = (
			);
			dependencies = (
				3DB372EA2E32739000A91180 /* PBXTargetDependency */,
			);
			name = "ming-ling-watch-os";
			packageProductDependencies = (
			);
			productName = "ming-ling-watch-os";
			productReference = 3DB372E12E32739000A91180 /* ming-ling-watch-os.app */;
			productType = "com.apple.product-type.application.watchapp2-container";
		};
		3DB372E62E32739000A91180 /* ming-ling-watch-os Watch App */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = 3DB3730A2E32739100A91180 /* Build configuration list for PBXNativeTarget "ming-ling-watch-os Watch App" */;
			buildPhases = (
				3DB372E32E32739000A91180 /* Sources */,
				3DB372E42E32739000A91180 /* Frameworks */,
				3DB372E52E32739000A91180 /* Resources */,
				3D83DEFA2E3353B400609605 /* Embed Foundation Extensions */,
			);
			buildRules = (
			);
			dependencies = (
			);
			fileSystemSynchronizedGroups = (
				3DB372EB2E32739000A91180 /* ming-ling-watch-os Watch App */,
			);
			name = "ming-ling-watch-os Watch App";
			packageProductDependencies = (
			);
			productName = "ming-ling-watch-os Watch App";
			productReference = 3DB372E72E32739000A91180 /* ming-ling-watch-os Watch App.app */;
			productType = "com.apple.product-type.application";
		};
		3DB372F52E32739100A91180 /* ming-ling-watch-os Watch AppTests */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = 3DB373112E32739100A91180 /* Build configuration list for PBXNativeTarget "ming-ling-watch-os Watch AppTests" */;
			buildPhases = (
				3DB372F22E32739100A91180 /* Sources */,
				3DB372F32E32739100A91180 /* Frameworks */,
				3DB372F42E32739100A91180 /* Resources */,
			);
			buildRules = (
			);
			dependencies = (
				3DB372F82E32739100A91180 /* PBXTargetDependency */,
			);
			fileSystemSynchronizedGroups = (
				3DB372F92E32739100A91180 /* ming-ling-watch-os Watch AppTests */,
			);
			name = "ming-ling-watch-os Watch AppTests";
			packageProductDependencies = (
			);
			productName = "ming-ling-watch-os Watch AppTests";
			productReference = 3DB372F62E32739100A91180 /* ming-ling-watch-os Watch AppTests.xctest */;
			productType = "com.apple.product-type.bundle.unit-test";
		};
		3DB372FF2E32739100A91180 /* ming-ling-watch-os Watch AppUITests */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = 3DB373142E32739100A91180 /* Build configuration list for PBXNativeTarget "ming-ling-watch-os Watch AppUITests" */;
			buildPhases = (
				3DB372FC2E32739100A91180 /* Sources */,
				3DB372FD2E32739100A91180 /* Frameworks */,
				3DB372FE2E32739100A91180 /* Resources */,
			);
			buildRules = (
			);
			dependencies = (
				3DB373022E32739100A91180 /* PBXTargetDependency */,
			);
			fileSystemSynchronizedGroups = (
				3DB373032E32739100A91180 /* ming-ling-watch-os Watch AppUITests */,
			);
			name = "ming-ling-watch-os Watch AppUITests";
			packageProductDependencies = (
			);
			productName = "ming-ling-watch-os Watch AppUITests";
			productReference = 3DB373002E32739100A91180 /* ming-ling-watch-os Watch AppUITests.xctest */;
			productType = "com.apple.product-type.bundle.ui-testing";
		};
/* End PBXNativeTarget section */

/* Begin PBXProject section */
		3DB372DB2E32738F00A91180 /* Project object */ = {
			isa = PBXProject;
			attributes = {
				BuildIndependentTargetsInParallel = 1;
				LastSwiftUpdateCheck = 1640;
				LastUpgradeCheck = 1640;
				TargetAttributes = {
					3DB372E02E32739000A91180 = {
						CreatedOnToolsVersion = 16.4;
					};
					3DB372E62E32739000A91180 = {
						CreatedOnToolsVersion = 16.4;
					};
					3DB372F52E32739100A91180 = {
						CreatedOnToolsVersion = 16.4;
						TestTargetID = 3DB372E62E32739000A91180;
					};
					3DB372FF2E32739100A91180 = {
						CreatedOnToolsVersion = 16.4;
						TestTargetID = 3DB372E62E32739000A91180;
					};
				};
			};
			buildConfigurationList = 3DB372DE2E32738F00A91180 /* Build configuration list for PBXProject "ming-ling-watch-os" */;
			developmentRegion = en;
			hasScannedForEncodings = 0;
			knownRegions = (
				en,
				Base,
			);
			mainGroup = 3DB372DA2E32738F00A91180;
			minimizedProjectReferenceProxies = 1;
			preferredProjectObjectVersion = 77;
			productRefGroup = 3DB372E22E32739000A91180 /* Products */;
			projectDirPath = "";
			projectRoot = "";
			targets = (
				3DB372E02E32739000A91180 /* ming-ling-watch-os */,
				3DB372E62E32739000A91180 /* ming-ling-watch-os Watch App */,
				3DB372F52E32739100A91180 /* ming-ling-watch-os Watch AppTests */,
				3DB372FF2E32739100A91180 /* ming-ling-watch-os Watch AppUITests */,
			);
		};
/* End PBXProject section */

/* Begin PBXResourcesBuildPhase section */
		3DB372DF2E32739000A91180 /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		3DB372E52E32739000A91180 /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		3DB372F42E32739100A91180 /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		3DB372FE2E32739100A91180 /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXResourcesBuildPhase section */

/* Begin PBXSourcesBuildPhase section */
		3DB372E32E32739000A91180 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		3DB372F22E32739100A91180 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		3DB372FC2E32739100A91180 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXSourcesBuildPhase section */

/* Begin PBXTargetDependency section */
		3DB372EA2E32739000A91180 /* PBXTargetDependency */ = {
			isa = PBXTargetDependency;
			target = 3DB372E62E32739000A91180 /* ming-ling-watch-os Watch App */;
			targetProxy = 3DB372E92E32739000A91180 /* PBXContainerItemProxy */;
		};
		3DB372F82E32739100A91180 /* PBXTargetDependency */ = {
			isa = PBXTargetDependency;
			target = 3DB372E62E32739000A91180 /* ming-ling-watch-os Watch App */;
			targetProxy = 3DB372F72E32739100A91180 /* PBXContainerItemProxy */;
		};
		3DB373022E32739100A91180 /* PBXTargetDependency */ = {
			isa = PBXTargetDependency;
			target = 3DB372E62E32739000A91180 /* ming-ling-watch-os Watch App */;
			targetProxy = 3DB373012E32739100A91180 /* PBXContainerItemProxy */;
		};
/* End PBXTargetDependency section */

/* Begin XCBuildConfiguration section */
		3DB373082E32739100A91180 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++20";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_ENABLE_OBJC_WEAK = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER = YES;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = dwarf;
				DEVELOPMENT_TEAM = NY895LXZ8G;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_TESTABILITY = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = YES;
				GCC_C_LANGUAGE_STANDARD = gnu17;
				GCC_DYNAMIC_NO_PIC = NO;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_OPTIMIZATION_LEVEL = 0;
				GCC_PREPROCESSOR_DEFINITIONS = (
					"DEBUG=1",
					"$(inherited)",
				);
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				LOCALIZATION_PREFERS_STRING_CATALOGS = YES;
				MTL_ENABLE_DEBUG_INFO = INCLUDE_SOURCE;
				MTL_FAST_MATH = YES;
				ONLY_ACTIVE_ARCH = YES;
				SWIFT_ACTIVE_COMPILATION_CONDITIONS = "DEBUG $(inherited)";
				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
			};
			name = Debug;
		};
		3DB373092E32739100A91180 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++20";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_ENABLE_OBJC_WEAK = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER = YES;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
				DEVELOPMENT_TEAM = NY895LXZ8G;
				ENABLE_NS_ASSERTIONS = NO;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = YES;
				GCC_C_LANGUAGE_STANDARD = gnu17;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				LOCALIZATION_PREFERS_STRING_CATALOGS = YES;
				MTL_ENABLE_DEBUG_INFO = NO;
				MTL_FAST_MATH = YES;
				SWIFT_COMPILATION_MODE = wholemodule;
			};
			name = Release;
		};
		3DB3730B2E32739100A91180 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				ASSETCATALOG_COMPILER_GLOBAL_ACCENT_COLOR_NAME = AccentColor;
				CODE_SIGN_ENTITLEMENTS = "ming-ling-watch-os Watch App/ming-ling-watch-os Watch App.entitlements";
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_TEAM = NY895LXZ8G;
				ENABLE_PREVIEWS = YES;
				GENERATE_INFOPLIST_FILE = YES;
				INFOPLIST_FILE = "ming-ling-watch-os-Watch-App-Info.plist";
				INFOPLIST_KEY_CFBundleDisplayName = "ming-ling-watch-os";
				INFOPLIST_KEY_LSApplicationCategoryType = "Privacy - Health Share Usage Description\n";
				INFOPLIST_KEY_NSHealthShareUsageDescription = "我们需要访问您的健康数据以帮助您分析睡眠、锻炼和日常活动。";
				INFOPLIST_KEY_NSHealthUpdateUsageDescription = "我们需要访问您的健康数据以帮助您分析睡眠、锻炼和日常活动。";
				INFOPLIST_KEY_NSLocationAlwaysAndWhenInUseUsageDescription = "我们需要访问您的健康数据以帮助您分析睡眠、锻炼和日常活动。";
				INFOPLIST_KEY_NSLocationWhenInUseUsageDescription = "我们需要访问您的健康数据以帮助您分析睡眠、锻炼和日常活动。";
				INFOPLIST_KEY_NSMotionUsageDescription = "我们需要访问您的健康数据以帮助您分析睡眠、锻炼和日常活动。";
				INFOPLIST_KEY_UISupportedInterfaceOrientations = "UIInterfaceOrientationPortrait UIInterfaceOrientationPortraitUpsideDown";
				INFOPLIST_KEY_WKWatchOnly = YES;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = "CreepOnSky.ming-ling-watch-os.watchkitapp";
				PRODUCT_NAME = "$(TARGET_NAME)";
				SDKROOT = watchos;
				SKIP_INSTALL = YES;
				SWIFT_EMIT_LOC_STRINGS = YES;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = 4;
				WATCHOS_DEPLOYMENT_TARGET = 11.5;
			};
			name = Debug;
		};
		3DB3730C2E32739100A91180 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				ASSETCATALOG_COMPILER_GLOBAL_ACCENT_COLOR_NAME = AccentColor;
				CODE_SIGN_ENTITLEMENTS = "ming-ling-watch-os Watch App/ming-ling-watch-os Watch App.entitlements";
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_TEAM = NY895LXZ8G;
				ENABLE_PREVIEWS = YES;
				GENERATE_INFOPLIST_FILE = YES;
				INFOPLIST_FILE = "ming-ling-watch-os-Watch-App-Info.plist";
				INFOPLIST_KEY_CFBundleDisplayName = "ming-ling-watch-os";
				INFOPLIST_KEY_LSApplicationCategoryType = "Privacy - Health Share Usage Description\n";
				INFOPLIST_KEY_NSHealthShareUsageDescription = "我们需要访问您的健康数据以帮助您分析睡眠、锻炼和日常活动。";
				INFOPLIST_KEY_NSHealthUpdateUsageDescription = "我们需要访问您的健康数据以帮助您分析睡眠、锻炼和日常活动。";
				INFOPLIST_KEY_NSLocationAlwaysAndWhenInUseUsageDescription = "我们需要访问您的健康数据以帮助您分析睡眠、锻炼和日常活动。";
				INFOPLIST_KEY_NSLocationWhenInUseUsageDescription = "我们需要访问您的健康数据以帮助您分析睡眠、锻炼和日常活动。";
				INFOPLIST_KEY_NSMotionUsageDescription = "我们需要访问您的健康数据以帮助您分析睡眠、锻炼和日常活动。";
				INFOPLIST_KEY_UISupportedInterfaceOrientations = "UIInterfaceOrientationPortrait UIInterfaceOrientationPortraitUpsideDown";
				INFOPLIST_KEY_WKWatchOnly = YES;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = "CreepOnSky.ming-ling-watch-os.watchkitapp";
				PRODUCT_NAME = "$(TARGET_NAME)";
				SDKROOT = watchos;
				SKIP_INSTALL = YES;
				SWIFT_EMIT_LOC_STRINGS = YES;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = 4;
				VALIDATE_PRODUCT = YES;
				WATCHOS_DEPLOYMENT_TARGET = 11.5;
			};
			name = Release;
		};
		3DB3730F2E32739100A91180 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_TEAM = NY895LXZ8G;
				INFOPLIST_KEY_CFBundleDisplayName = "ming-ling-watch-os";
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = "CreepOnSky.ming-ling-watch-os";
				PRODUCT_NAME = "$(TARGET_NAME)";
				SDKROOT = iphoneos;
				SWIFT_VERSION = 5.0;
			};
			name = Debug;
		};
		3DB373102E32739100A91180 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_TEAM = NY895LXZ8G;
				INFOPLIST_KEY_CFBundleDisplayName = "ming-ling-watch-os";
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = "CreepOnSky.ming-ling-watch-os";
				PRODUCT_NAME = "$(TARGET_NAME)";
				SDKROOT = iphoneos;
				SWIFT_VERSION = 5.0;
				VALIDATE_PRODUCT = YES;
			};
			name = Release;
		};
		3DB373122E32739100A91180 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				BUNDLE_LOADER = "$(TEST_HOST)";
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_TEAM = NY895LXZ8G;
				GENERATE_INFOPLIST_FILE = YES;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = "CreepOnSky.ming-ling-watch-os-Watch-AppTests";
				PRODUCT_NAME = "$(TARGET_NAME)";
				SDKROOT = watchos;
				SWIFT_EMIT_LOC_STRINGS = NO;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = 4;
				TEST_HOST = "$(BUILT_PRODUCTS_DIR)/ming-ling-watch-os Watch App.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/ming-ling-watch-os Watch App";
				WATCHOS_DEPLOYMENT_TARGET = 11.5;
			};
			name = Debug;
		};
		3DB373132E32739100A91180 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				BUNDLE_LOADER = "$(TEST_HOST)";
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_TEAM = NY895LXZ8G;
				GENERATE_INFOPLIST_FILE = YES;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = "CreepOnSky.ming-ling-watch-os-Watch-AppTests";
				PRODUCT_NAME = "$(TARGET_NAME)";
				SDKROOT = watchos;
				SWIFT_EMIT_LOC_STRINGS = NO;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = 4;
				TEST_HOST = "$(BUILT_PRODUCTS_DIR)/ming-ling-watch-os Watch App.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/ming-ling-watch-os Watch App";
				VALIDATE_PRODUCT = YES;
				WATCHOS_DEPLOYMENT_TARGET = 11.5;
			};
			name = Release;
		};
		3DB373152E32739100A91180 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_TEAM = NY895LXZ8G;
				GENERATE_INFOPLIST_FILE = YES;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = "CreepOnSky.ming-ling-watch-os-Watch-AppUITests";
				PRODUCT_NAME = "$(TARGET_NAME)";
				SDKROOT = watchos;
				SWIFT_EMIT_LOC_STRINGS = NO;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = 4;
				TEST_TARGET_NAME = "ming-ling-watch-os Watch App";
				WATCHOS_DEPLOYMENT_TARGET = 11.5;
			};
			name = Debug;
		};
		3DB373162E32739100A91180 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_TEAM = NY895LXZ8G;
				GENERATE_INFOPLIST_FILE = YES;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = "CreepOnSky.ming-ling-watch-os-Watch-AppUITests";
				PRODUCT_NAME = "$(TARGET_NAME)";
				SDKROOT = watchos;
				SWIFT_EMIT_LOC_STRINGS = NO;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = 4;
				TEST_TARGET_NAME = "ming-ling-watch-os Watch App";
				VALIDATE_PRODUCT = YES;
				WATCHOS_DEPLOYMENT_TARGET = 11.5;
			};
			name = Release;
		};
/* End XCBuildConfiguration section */

/* Begin XCConfigurationList section */
		3DB372DE2E32738F00A91180 /* Build configuration list for PBXProject "ming-ling-watch-os" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				3DB373082E32739100A91180 /* Debug */,
				3DB373092E32739100A91180 /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		3DB3730A2E32739100A91180 /* Build configuration list for PBXNativeTarget "ming-ling-watch-os Watch App" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				3DB3730B2E32739100A91180 /* Debug */,
				3DB3730C2E32739100A91180 /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		3DB3730E2E32739100A91180 /* Build configuration list for PBXNativeTarget "ming-ling-watch-os" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				3DB3730F2E32739100A91180 /* Debug */,
				3DB373102E32739100A91180 /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		3DB373112E32739100A91180 /* Build configuration list for PBXNativeTarget "ming-ling-watch-os Watch AppTests" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				3DB373122E32739100A91180 /* Debug */,
				3DB373132E32739100A91180 /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		3DB373142E32739100A91180 /* Build configuration list for PBXNativeTarget "ming-ling-watch-os Watch AppUITests" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				3DB373152E32739100A91180 /* Debug */,
				3DB373162E32739100A91180 /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
/* End XCConfigurationList section */
	};
	rootObject = 3DB372DB2E32738F00A91180 /* Project object */;
}

----

----
FilePath: ming-ling-watch-os.xcodeproj/project.xcworkspace/contents.xcworkspacedata
Lines: 7
<?xml version="1.0" encoding="UTF-8"?>
<Workspace
   version = "1.0">
   <FileRef
      location = "self:">
   </FileRef>
</Workspace>

----

----
FilePath: ming-ling-watch-os.xcodeproj/xcuserdata/zuowenhao.xcuserdatad/xcschemes/xcschememanagement.plist
Lines: 24
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>SchemeUserState</key>
	<dict>
		<key>ming-ling-watch-os Watch App (Notification).xcscheme_^#shared#^_</key>
		<dict>
			<key>orderHint</key>
			<integer>1</integer>
		</dict>
		<key>ming-ling-watch-os Watch App.xcscheme_^#shared#^_</key>
		<dict>
			<key>orderHint</key>
			<integer>0</integer>
		</dict>
		<key>mingling-notifcation.xcscheme_^#shared#^_</key>
		<dict>
			<key>orderHint</key>
			<integer>1</integer>
		</dict>
	</dict>
</dict>
</plist>

----

----
FilePath: ming-ling-watch-os.xcworkspace/contents.xcworkspacedata
Lines: 10
<?xml version="1.0" encoding="UTF-8"?>
<Workspace
   version = "1.0">
   <FileRef
      location = "group:ming-ling-watch-os.xcodeproj">
   </FileRef>
   <FileRef
      location = "group:Pods/Pods.xcodeproj">
   </FileRef>
</Workspace>

----

----
FilePath: mingling-notifcation/Info.plist
Lines: 13
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>NSExtension</key>
	<dict>
		<key>NSExtensionPointIdentifier</key>
		<string>com.apple.usernotifications.service</string>
		<key>NSExtensionPrincipalClass</key>
		<string>$(PRODUCT_MODULE_NAME).NotificationService</string>
	</dict>
</dict>
</plist>

----

----
FilePath: mingling-notifcation/NotificationService.swift
Lines: 35
//
//  NotificationService.swift
//  mingling-notifcation
//
//  Created by CreepOnSky on 2025/7/25.
//

import UserNotifications

class NotificationService: UNNotificationServiceExtension {

    var contentHandler: ((UNNotificationContent) -> Void)?
    var bestAttemptContent: UNMutableNotificationContent?

    override func didReceive(_ request: UNNotificationRequest, withContentHandler contentHandler: @escaping (UNNotificationContent) -> Void) {
        self.contentHandler = contentHandler
        bestAttemptContent = (request.content.mutableCopy() as? UNMutableNotificationContent)
        
        if let bestAttemptContent = bestAttemptContent {
            // Modify the notification content here...
            bestAttemptContent.title = "\(bestAttemptContent.title) [modified]"
            
            contentHandler(bestAttemptContent)
        }
    }
    
    override func serviceExtensionTimeWillExpire() {
        // Called just before the extension will be terminated by the system.
        // Use this as an opportunity to deliver your "best attempt" at modified content, otherwise the original push payload will be used.
        if let contentHandler = contentHandler, let bestAttemptContent =  bestAttemptContent {
            contentHandler(bestAttemptContent)
        }
    }

}

----
